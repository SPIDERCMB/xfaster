<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>xfaster.xfaster_class &mdash; xfaster 1.0.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"equationNumbers": {"autoNumber": "AMS", "useLabelIds": true}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> xfaster
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithm.html">Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/XFaster_Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">xfaster</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>xfaster.xfaster_class</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for xfaster.xfaster_class</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spec_tools</span> <span class="k">as</span> <span class="n">st</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parse_tools</span> <span class="k">as</span> <span class="n">pt</span>
<span class="kn">from</span> <span class="nn">configparser</span> <span class="kn">import</span> <span class="n">RawConfigParser</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;XFasterConfig&quot;</span><span class="p">,</span> <span class="s2">&quot;XFaster&quot;</span><span class="p">,</span> <span class="s2">&quot;XFasterWarning&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="XFasterWarning"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterWarning">[docs]</a><span class="k">class</span> <span class="nc">XFasterWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning generated by the XFaster algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="XFasterConfig"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig">[docs]</a><span class="k">class</span> <span class="nc">XFasterConfig</span><span class="p">(</span><span class="n">RawConfigParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ConfigParser subclass for storing command line options and config.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_sec</span><span class="o">=</span><span class="s2">&quot;Uncategorized&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class that tracks command-line options for storage to disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        defaults : dict</span>
<span class="sd">            Dictionary of overall configuration values.</span>
<span class="sd">            Eg: locals() at beginning of function, or vars(args) from argparse</span>
<span class="sd">        default_sec : string, optional</span>
<span class="sd">            The name of the default section in the configuration file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">XFasterConfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dict_type</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span> <span class="o">=</span> <span class="n">default_sec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="n">default_sec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>

<div class="viewcode-block" id="XFasterConfig.update"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update configuration options with a dictionary. Behaves like</span>
<span class="sd">        dict.update() for specified section but also clears options of the same</span>
<span class="sd">        name from the default section.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        options : dict</span>
<span class="sd">            The options to update</span>
<span class="sd">        section : string, optional</span>
<span class="sd">            Name of section to update. Default: self.default_sec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_section</span><span class="p">(</span><span class="n">section</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="c1"># change kwargs to be like any other options</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_sec</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFasterConfig.sort"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the items in each section of the configuration alphabetically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">section</span><span class="p">,</span> <span class="n">section_items</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">section_items</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">section_items</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">section_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">section_items</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">section_items</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_option</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">section_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFasterConfig.write"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFasterConfig.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write an .ini-format representation of the configuration state.</span>
<span class="sd">        Keys are stored alphabetically if `sort` is True.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        fp : file object</span>
<span class="sd">            If None, write to `sys.stdout`.</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If True, sort items in each section alphabetically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">sys</span>

            <span class="n">fp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">XFasterConfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="XFaster"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster">[docs]</a><span class="k">class</span> <span class="nc">XFaster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;files&quot;</span><span class="p">,</span>
        <span class="s2">&quot;masks&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kernels&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sims_transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shape_transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;transfer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sims&quot;</span><span class="p">,</span>
        <span class="s2">&quot;beams&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sim_data&quot;</span><span class="p">,</span>
        <span class="s2">&quot;template_noise&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bandpowers&quot;</span><span class="p">,</span>
        <span class="s2">&quot;beam_errors&quot;</span><span class="p">,</span>
        <span class="s2">&quot;likelihood&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># if starting from KEY, force rerun all steps in VALUES</span>
    <span class="n">checkpoint_tree</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;files&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">],</span>
        <span class="s2">&quot;masks&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">&quot;kernels&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sims_transfer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sims&quot;</span><span class="p">,</span>
            <span class="s2">&quot;data&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sim_data&quot;</span><span class="p">,</span>
            <span class="s2">&quot;template_noise&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;kernels&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sims_transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;shape_transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;transfer&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sims&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;beams&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
        <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;sim_data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;template_noise&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;bandpowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;bandpowers&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;likelihood&quot;</span><span class="p">],</span>
        <span class="s2">&quot;beam_errors&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;likelihood&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">data_version</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config</span><span class="p">,</span>
        <span class="n">output_root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">output_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="s2">&quot;notice&quot;</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">checkpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">add_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an XFaster instance for computing binned power spectra</span>
<span class="sd">        using a set of data maps along with signal and noise simulations.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        config : string</span>
<span class="sd">            Configuration file. If path doesn&#39;t exist, assumed</span>
<span class="sd">            to be in xfaster/config/&lt;config&gt;</span>
<span class="sd">        output_root : string</span>
<span class="sd">            Path to data output directory</span>
<span class="sd">        output_tag : string</span>
<span class="sd">            Tag to use for output data.  Results are typically stored in</span>
<span class="sd">            the form ``&lt;output_root&gt;/&lt;output_tag&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``</span>
<span class="sd">        verbose : string</span>
<span class="sd">            Verbosity level to use for log messages.  Can be one of</span>
<span class="sd">            [&quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;].</span>
<span class="sd">        debug : bool</span>
<span class="sd">            Store extra data in output files for debugging.</span>
<span class="sd">        checkpoint : string</span>
<span class="sd">            If output data from this step forward exist on disk, they are</span>
<span class="sd">            are re-computed rather than loading from file.</span>
<span class="sd">            Options are {checkpoints}.</span>
<span class="sd">        add_log : bool</span>
<span class="sd">            If True, write log output to a file instead of to STDOUT.</span>
<span class="sd">            The log will be in ``&lt;output_root&gt;/run_&lt;output_tag&gt;.log``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_log</span><span class="p">(</span>
            <span class="n">level</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="s2">&quot;run&quot;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.log&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">add_log</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="c1"># map tag configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_map_config</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

        <span class="c1"># checkpointing</span>
        <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">checkpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">=</span> <span class="n">checkpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span> <span class="o">=</span> <span class="p">{</span><span class="n">cp</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">output_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No output root supplied, using </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_root</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="o">=</span> <span class="n">output_root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span> <span class="o">=</span> <span class="n">output_tag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">)</span>

    <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="fm">__init__</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">checkpoints</span><span class="o">=</span><span class="n">checkpoints</span><span class="p">)</span>

<div class="viewcode-block" id="XFaster.load_map_config"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.load_map_config">[docs]</a>    <span class="k">def</span> <span class="nf">load_map_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the input map configuration file.</span>

<span class="sd">        The configuration file should be a file that is readable using</span>
<span class="sd">        ``ConfigParser``.  It must contain at least a single section called</span>
<span class="sd">        &quot;frequencies&quot;, with keys for each map tag that may be used by the</span>
<span class="sd">        algorithm.  If using the harmonic-domain foreground fitting portions of</span>
<span class="sd">        the algorith, the value of each key should be the observing frequency in</span>
<span class="sd">        GHz that is appropriate for each tag.  Otherwise, these frequencies can</span>
<span class="sd">        be any floating point value.</span>

<span class="sd">        Other optional sections include:</span>

<span class="sd">        **beam**:</span>
<span class="sd">        Beam window specifications for each of the tags in &quot;frequencies&quot;.  The</span>
<span class="sd">        &quot;beam_product&quot; key should be a path to a .npz file containing a</span>
<span class="sd">        dictionary of beam windows keyed by tag.  The &quot;beam_product_error&quot; key</span>
<span class="sd">        should be a path to a similar dictionary containing fraction beam error</span>
<span class="sd">        envelopes, also keyed by tag.  See ``get_beams`` or ``get_beam_errors``</span>
<span class="sd">        for more details.</span>

<span class="sd">        **fwhm**:</span>
<span class="sd">        If using a Gaussian beam model, this section should contain a list of</span>
<span class="sd">        FWHM in arcmin for each such tag in &quot;frequencies&quot;.  Keys missing here</span>
<span class="sd">        should be present in the beam product file.</span>

<span class="sd">        **fwhm_err**:</span>
<span class="sd">        If using a Gaussian beam model, this section should contain a list of</span>
<span class="sd">        fractional errors on the FWHM for each such tag in &quot;frequencies&quot;.  Keys</span>
<span class="sd">        missing here should be present in the beam error product file.</span>

<span class="sd">        **transfer**:</span>
<span class="sd">        If present, this section should contain each of the keys in</span>
<span class="sd">        &quot;frequencies&quot;, with the value set to &quot;true&quot; if a transfer function</span>
<span class="sd">        should be computed for the tag, and &quot;false&quot; otherwise (in which case the</span>
<span class="sd">        transfer function will be set to unity for all bins).  This option is</span>
<span class="sd">        useful for including, e.g. optimally weighted Planck maps with no</span>
<span class="sd">        transfer function in a joint analysis.  If not supplied, it is assumed</span>
<span class="sd">        that a transfer function should be computed for every tag in</span>
<span class="sd">        &quot;frequencies&quot;.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Path to config file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Load map configuration file</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;Missing config file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">XFasterConfig</span><span class="p">()</span>
        <span class="n">cfg</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># dictionary of map frequencies keyed by map tag</span>
        <span class="k">assert</span> <span class="s2">&quot;frequencies&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">,</span> <span class="s2">&quot;Missing [frequencies] section&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;frequencies&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;frequencies&quot;</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="n">tagset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one map tag is required&quot;</span>

        <span class="c1"># beam fwhm for each tag, if not supplied in beam_product</span>
        <span class="c1"># converted from arcmin to radians</span>
        <span class="k">if</span> <span class="s2">&quot;fwhm&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s2">&quot;fwhm&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;fwhm&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="mf">60.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># beam fwhm error for each tag, if not supplied in beam_error_product</span>
        <span class="k">if</span> <span class="s2">&quot;fwhm_err&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s2">&quot;fwhm_err&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getfloat</span><span class="p">(</span><span class="s2">&quot;fwhm_err&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make sure beam product files exist</span>
        <span class="k">if</span> <span class="s2">&quot;beam&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;beam_product&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Missing beam product file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_compat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># Only use the fields in the beam product we need</span>
                <span class="k">for</span> <span class="n">btag</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">)</span> <span class="o">-</span> <span class="n">tagset</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">btag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;beam_error_product&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Missing beam error product file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_compat</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># Only use the fields in the beam product we need</span>
                <span class="k">for</span> <span class="n">btag</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">)</span> <span class="o">-</span> <span class="n">tagset</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">btag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># make sure all tags are present in either beam products or fwhm tables</span>
        <span class="n">fwhm_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">fwhm_set</span> <span class="o">==</span> <span class="n">tagset</span><span class="p">,</span> <span class="s2">&quot;Missing tags in [fwhm] or beam product&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">):</span>
            <span class="n">fwhm_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">fwhm_set</span> <span class="o">==</span> <span class="n">tagset</span>
            <span class="p">),</span> <span class="s2">&quot;Missing tags in [fwhm_err] or beam error product&quot;</span>

        <span class="c1"># fit for the transfer function for each tag?</span>
        <span class="k">if</span> <span class="s2">&quot;transfer&quot;</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">has_option</span><span class="p">(</span><span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">cfg</span><span class="o">.</span><span class="n">getboolean</span><span class="p">(</span><span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">}</span>
            <span class="k">assert</span> <span class="n">tagset</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span><span class="p">),</span> <span class="s2">&quot;Missing tags in [transfer]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assume true for all tags otherwise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">}</span></div>

<div class="viewcode-block" id="XFaster.init_log"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.init_log">[docs]</a>    <span class="k">def</span> <span class="nf">init_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;notice&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the logger from the input keyword arguments.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        level : string, optional, default: &quot;notice&quot;</span>
<span class="sd">            Verbosity level.</span>
<span class="sd">            Options are &quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;, &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;.</span>
<span class="sd">        filename : string, optional</span>
<span class="sd">            Logging output filename.  Default: None (print to sys.stdout)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># add NOTICE logging level</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span> <span class="o">=</span> <span class="mi">25</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">,</span> <span class="s2">&quot;NOTICE&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">logger_notice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log a message with severity &quot;NOTICE&quot;.</span>

<span class="sd">            Arguments</span>
<span class="sd">            ---------</span>
<span class="sd">            msg : str</span>
<span class="sd">                Log message</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">NOTICE</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">notice</span> <span class="o">=</span> <span class="n">logger_notice</span>

        <span class="k">def</span> <span class="nf">root_notice</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log a message with severity &quot;NOTICE&quot; on the root logger.</span>

<span class="sd">            Arguments</span>
<span class="sd">            ---------</span>
<span class="sd">            msg : str</span>
<span class="sd">                Log message</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">handlers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">notice</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">notice</span> <span class="o">=</span> <span class="n">root_notice</span>

        <span class="c1"># create handler</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.batch_tools</span> <span class="kn">import</span> <span class="n">get_job_logfile</span>

            <span class="n">filename</span> <span class="o">=</span> <span class="n">get_job_logfile</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># create formatter</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span>
            <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;[ </span><span class="si">%(asctime)s</span><span class="s2"> ] </span><span class="si">%(levelname)s</span><span class="s2">: </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S%Z&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="c1"># configure logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;xfaster&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

        <span class="c1"># set logging level</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notice&quot;</span>
        <span class="k">elif</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notset&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">logging</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span></div>

<div class="viewcode-block" id="XFaster.log"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a message with the given logging level.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        message : str</span>
<span class="sd">            Log message</span>
<span class="sd">        level : string, default : None</span>
<span class="sd">            Logging level.  Must be one of &quot;critical&quot;, &quot;error&quot;, &quot;warning&quot;,</span>
<span class="sd">            &quot;notice&quot;, &quot;info&quot;, &quot;debug&quot;, &quot;all&quot;.  If not supplied, &quot;all&quot; is assumed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">level</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="s2">&quot;notset&quot;</span>
        <span class="n">level</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">logging</span><span class="p">,</span> <span class="n">level</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.warn"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.warn">[docs]</a>    <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log a warning message.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        message : str</span>
<span class="sd">            Warning log message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">XFasterWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure logger is shutdown properly when the object is destroyed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># cleanup logging handlers</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">OSError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_data_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_type</span><span class="p">,</span>
        <span class="n">data_root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_root2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_subset2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for finding all matching map data files.  Used</span>
<span class="sd">        internally in ``get_files``.</span>

<span class="sd">        This function runs in two modes, depending on the value of ``config``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        data_type : string</span>
<span class="sd">            The type of data to use, required.</span>
<span class="sd">        data_root : string</span>
<span class="sd">            Top level path containing subdirectories for data, signal sims,</span>
<span class="sd">            noise sims, and masks.</span>
<span class="sd">        data_subset : string</span>
<span class="sd">            Subset of maps to use for spectrum estimation.  This should be</span>
<span class="sd">            a string that is parseable using ``glob`` on the path</span>
<span class="sd">            ``data_&lt;data_type&gt;/&lt;data_subset&gt;.fits``.  For example,</span>
<span class="sd">            ``&#39;full/*0&#39;`` will expand to read in the 150 GHz and 90GHz maps.</span>
<span class="sd">            Maps are then sorted in alphabetical order, and identified</span>
<span class="sd">            by their file tag, where each filename is ``map_&lt;tag&gt;.fits``.</span>
<span class="sd">        data_root2, data_subset2 : string</span>
<span class="sd">            The root and subset for a second set of data.  If either of these is</span>
<span class="sd">            keywords is supplied, then the two data sets are treated as two</span>
<span class="sd">            halves of a null test.  In this case, XFaster computes the sum and</span>
<span class="sd">            difference spectra for each map tag in order to estimate a null</span>
<span class="sd">            spectrum.</span>
<span class="sd">        config : bool</span>
<span class="sd">            If True, return a dictionary of attributes for defining the run</span>
<span class="sd">            configuration, such as properly constructed data roots, map tags and</span>
<span class="sd">            cross-spectrum pairings.  If False, return a dictionary of map</span>
<span class="sd">            filenames and file roots for building the appropriate cross spectra</span>
<span class="sd">            with ``get_masked_data()``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of configuration options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="p">:</span>
            <span class="n">num_maps</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">map_tags_check</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">null_run</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">data_root2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">data_subset2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_root2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data_root2</span> <span class="o">=</span> <span class="n">data_root</span>
                <span class="k">if</span> <span class="n">data_subset2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data_subset2</span> <span class="o">=</span> <span class="n">data_subset</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">data_subset</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">data_root2</span><span class="p">,</span> <span class="n">data_subset2</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Either data_root2 or data_subset2 must differ &quot;</span>
                        <span class="s2">&quot;from data_root/data_subset&quot;</span>
                    <span class="p">)</span>
                <span class="n">null_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_maps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_names</span><span class="p">)</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_names</span><span class="p">]</span>
            <span class="n">map_tags_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="p">])</span>
            <span class="n">null_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span>
            <span class="n">data_root</span> <span class="o">=</span> <span class="n">data_root</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_root</span>
            <span class="n">data_subset</span> <span class="o">=</span> <span class="n">data_subset</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_subset</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">data_root2</span> <span class="o">=</span> <span class="n">data_root2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_root2</span>
                <span class="n">data_subset2</span> <span class="o">=</span> <span class="n">data_subset2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_subset2</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument `data_type` required&quot;</span><span class="p">)</span>

        <span class="n">sets</span> <span class="o">=</span> <span class="p">[(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">data_subset</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">data_root2</span><span class="p">,</span> <span class="n">data_subset2</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">)]</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">droot</span><span class="p">,</span> <span class="n">dset</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">droot</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing data root </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">droot</span><span class="p">))</span>

            <span class="c1"># find all map files</span>
            <span class="n">map_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">droot</span><span class="p">,</span> <span class="s2">&quot;data_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_type</span><span class="p">))</span>
            <span class="n">map_files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)):</span>
                <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">map_root</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing files in data subset </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                <span class="n">map_files</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
            <span class="n">map_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">map_files</span><span class="p">)</span>
            <span class="n">map_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;map_&quot;</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">num_maps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_maps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_files</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_files</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_maps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> maps in root </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">map_files</span><span class="p">),</span> <span class="n">map_root</span><span class="p">,</span> <span class="n">dset</span><span class="p">,</span> <span class="n">num_maps</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># extract tag for each map</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">]</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_tags</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Map tags: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_tags</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">map_tags_check</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">map_tags_check</span> <span class="o">=</span> <span class="n">map_tags</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">map_tags</span> <span class="o">!=</span> <span class="n">map_tags_check</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Found map tags </span><span class="si">{}</span><span class="s2"> in root </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">map_tags</span><span class="p">,</span> <span class="n">map_root</span><span class="p">,</span> <span class="n">dset</span><span class="p">,</span> <span class="n">map_tags_check</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">config</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;map_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span> <span class="n">map_root</span><span class="p">,</span>
                            <span class="s2">&quot;map_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span> <span class="n">map_files</span><span class="p">,</span>
                        <span class="p">}</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> map files in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_maps</span><span class="p">,</span> <span class="n">map_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Map files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_files</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c1"># file names relative to map_root</span>
            <span class="n">map_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">map_root</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">]</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;data_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span> <span class="n">droot</span><span class="p">,</span>
                    <span class="s2">&quot;data_subset</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span> <span class="n">dset</span><span class="p">,</span>
                    <span class="s2">&quot;map_names</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span> <span class="n">map_names</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;map_tags&quot;</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Also need a list of unique map tags for populating dictionaries</span>
            <span class="c1"># in data structures</span>
            <span class="n">map_tags_orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>  <span class="c1"># copy</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">unique_tags</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

            <span class="c1"># make a list of names corresponding to the order of the cross spectra</span>
            <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>
            <span class="n">map_pairs_orig</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">map_tags_orig</span><span class="p">)</span>

            <span class="c1"># make a dictionary of map frequencies for each unique map tag</span>
            <span class="n">map_freqs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dict_freqs</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">map_tags_orig</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Map freqs: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_freqs</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">null_run</span><span class="o">=</span><span class="n">null_run</span><span class="p">,</span>
                <span class="n">num_maps</span><span class="o">=</span><span class="n">num_maps</span><span class="p">,</span>
                <span class="n">map_names</span><span class="o">=</span><span class="n">map_names</span><span class="p">,</span>
                <span class="n">map_tags</span><span class="o">=</span><span class="n">map_tags</span><span class="p">,</span>
                <span class="n">map_pairs</span><span class="o">=</span><span class="n">map_pairs</span><span class="p">,</span>
                <span class="n">map_tags_orig</span><span class="o">=</span><span class="n">map_tags_orig</span><span class="p">,</span>
                <span class="n">map_pairs_orig</span><span class="o">=</span><span class="n">map_pairs_orig</span><span class="p">,</span>
                <span class="n">map_freqs</span><span class="o">=</span><span class="n">map_freqs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_get_mask_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function or finding mask file for each map.  Used internally</span>
<span class="sd">        in ``get_files()``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        mask_type : string</span>
<span class="sd">            The variant of mask to use, e.g. &#39;rectangle&#39;, etc.  We assume a mask</span>
<span class="sd">            per file tag in the masks_&lt;mask_type&gt; folder, corresponding to the</span>
<span class="sd">            files in data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of mask file options, including mask_type, mask_root, and</span>
<span class="sd">            mask_files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument `mask_type` required&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">mask_type</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.fits&quot;</span><span class="p">:</span>
            <span class="c1"># use the same mask file for all maps</span>
            <span class="n">mask_file</span> <span class="o">=</span> <span class="n">mask_type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_file</span><span class="p">):</span>
                <span class="n">mask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_root</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_file</span><span class="p">):</span>
                <span class="n">mask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mask_file</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing mask file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_type</span><span class="p">))</span>

            <span class="n">mask_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_names</span><span class="p">))</span>
            <span class="n">mask_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">mask_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find all masks corresponding to each map tag</span>
            <span class="n">mask_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_root</span><span class="p">,</span> <span class="s2">&quot;masks_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_type</span><span class="p">))</span>
            <span class="c1"># XXX Do this smarter</span>
            <span class="c1"># e.g. allow different masks for different chunks?</span>
            <span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mask_root</span><span class="p">,</span> <span class="s2">&quot;mask_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_names</span>
            <span class="p">]</span>

        <span class="c1"># check that all mask files exist on disk</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mask_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing mask file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> masks in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_files</span><span class="p">),</span> <span class="n">mask_root</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_files</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mask_type</span><span class="o">=</span><span class="n">mask_type</span><span class="p">,</span> <span class="n">mask_root</span><span class="o">=</span><span class="n">mask_root</span><span class="p">,</span> <span class="n">mask_files</span><span class="o">=</span><span class="n">mask_files</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_sim_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for finding all matching sims per map.  Used</span>
<span class="sd">        internally in ``get_files`` for selecting appropriate subsets of</span>
<span class="sd">        simulation files.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : str</span>
<span class="sd">            Type of simulation files to collect (signal, noise, foreground,</span>
<span class="sd">            template)</span>
<span class="sd">        ctype : str</span>
<span class="sd">            The type value associated with ``name``.  If supplied, set ``root``</span>
<span class="sd">            to ``&lt;name&gt;_&lt;ctype&gt;``, with ``name`` truncated before the first</span>
<span class="sd">            underscore.</span>
<span class="sd">        subset : str</span>
<span class="sd">            Data subset to search for.  See ``get_files`` for details.</span>
<span class="sd">        root : str</span>
<span class="sd">            Root of the simulation file tree, relative to data_root.  If not</span>
<span class="sd">            supplied and ``ctype`` is None, the returned set of variables are</span>
<span class="sd">            set to null values.</span>
<span class="sd">        sim_data : bool</span>
<span class="sd">            If True, build a list of files associated with the</span>
<span class="sd">            ``signal_type_sim``, ``noise_type_sim``, etc options to</span>
<span class="sd">            ``get_files()``, including the appropriate attribute names.  The</span>
<span class="sd">            value of ``subset`` is ignored.  If False, ensure that the same</span>
<span class="sd">            number of maps is selected for each map tag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of sim file options for use with ``get_masked_sims()`` or</span>
<span class="sd">            ``get_masked_data()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">num_files</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">sim_data</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;_sim&quot;</span>
            <span class="n">match_count</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">match_count</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_type</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sim_data</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_subset&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">subset</span>

        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">suff</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]:</span>

            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_root</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">suff</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_files</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">suff</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;num_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">data_root</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;data_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">))</span>
            <span class="n">map_files</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;map_names</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">suff</span><span class="p">))</span>

            <span class="n">root1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="n">all_files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">:</span>
                <span class="n">files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">root1</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subset</span><span class="p">))</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nfiles</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing </span><span class="si">{}</span><span class="s2"> sims for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_files</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">num_files</span> <span class="o">=</span> <span class="n">nfiles</span>
                <span class="k">elif</span> <span class="n">num_files</span> <span class="o">!=</span> <span class="n">nfiles</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">match_count</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> sims for map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nfiles</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">num_files</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">nfiles</span> <span class="o">&lt;</span> <span class="n">num_files</span><span class="p">:</span>
                        <span class="n">num_files</span> <span class="o">=</span> <span class="n">nfiles</span>

                <span class="n">all_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

            <span class="n">all_files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">f</span><span class="p">[:</span><span class="n">num_files</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">all_files</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> sims in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_files</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">root1</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;First </span><span class="si">{}</span><span class="s2"> sim files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">all_files</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="s2">&quot;debug&quot;</span>
            <span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_root</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">suff</span><span class="p">):</span> <span class="n">root1</span><span class="p">,</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_files</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">suff</span><span class="p">):</span> <span class="n">all_files</span><span class="p">,</span>
                    <span class="s2">&quot;num_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span> <span class="n">num_files</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_get_sim_data_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for finding any matching sims per map to be used</span>
<span class="sd">        for simulating the input data with ``get_masked_data()`` in sim mode.</span>
<span class="sd">        Used internally in ``get_files()``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : str</span>
<span class="sd">            Type of simulation files to collect (signal, noise, foreground,</span>
<span class="sd">            template)</span>
<span class="sd">        ctype : str</span>
<span class="sd">            The type value associated with ``name``.  If not supplied, the</span>
<span class="sd">            returned set of variables are set to null values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of sim file options for use with ``get_masked_data()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;signal&quot;</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s2">&quot;signal_r0&quot;</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span><span class="s2">&quot;tensor&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="s2">&quot;signal_r1tens&quot;</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;signal_type_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctype</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;template&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_template_files</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;_sim&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_template_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for finding matching template maps per map,</span>
<span class="sd">        to be used for template subtraction in ``get_masked_data()``.</span>
<span class="sd">        Used internally in ``get_files()``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : str</span>
<span class="sd">            Type of simulation files to collect (signal, noise, foreground,</span>
<span class="sd">            template)</span>
<span class="sd">        ctype : str</span>
<span class="sd">            The type value associated with ``name``.  If not supplied, the</span>
<span class="sd">            returned set of variables are set to null values.</span>
<span class="sd">        suffix : str</span>
<span class="sd">            Suffix to apply to variable names, e.g. ``&quot;_sim&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of template file options for use with</span>
<span class="sd">            ``get_masked_data()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nfiles</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_type</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="s2">&quot;templates&quot;</span><span class="p">),</span> <span class="n">ctype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]:</span>
            <span class="n">suffix1</span> <span class="o">=</span> <span class="n">suffix</span> <span class="o">+</span> <span class="p">(</span><span class="n">group</span> <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;2&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix1</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix1</span><span class="p">):</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;num_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">root1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_root</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s2">&quot;template</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_names</span><span class="p">:</span>
                <span class="c1"># single template per map</span>
                <span class="n">tf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tf</span><span class="p">):</span>
                    <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># ensemble of templates per map</span>
                <span class="n">tf</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_*.fits&quot;</span><span class="p">)))</span>
                <span class="n">nfiles1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nfiles1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                        <span class="s2">&quot;Missing temp</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> files for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">nfiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nfiles</span> <span class="o">=</span> <span class="n">nfiles1</span>
                <span class="k">elif</span> <span class="n">nfiles1</span> <span class="o">!=</span> <span class="n">nfiles</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                        <span class="s2">&quot;Wrong number of </span><span class="si">{}</span><span class="s2"> sims. Found </span><span class="si">{}</span><span class="s2"> files, expected </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="n">nfiles1</span><span class="p">,</span> <span class="n">nfiles</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

            <span class="n">files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nfiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nfiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">files</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nfiles</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                    <span class="s2">&quot;Wrong number of </span><span class="si">{}</span><span class="s2"> files. Found </span><span class="si">{}</span><span class="s2"> files, expected </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">,</span> <span class="n">files</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nfiles</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> templates in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nfiles</span><span class="p">,</span> <span class="n">root1</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_root</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix1</span><span class="p">):</span> <span class="n">root1</span><span class="p">,</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_files</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix1</span><span class="p">):</span> <span class="n">files</span><span class="p">,</span>
                    <span class="s2">&quot;num_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span> <span class="n">nfiles</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_get_reference_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for finding all reference files per map, to be used</span>
<span class="sd">        for reference signal subtraction for null tests in ``get_masked_data()``.</span>
<span class="sd">        Used internally in ``get_files()``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        ctype : str</span>
<span class="sd">           The reference type to use.  If not supplied, the returned set of</span>
<span class="sd">           variables are set to null values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        opts : dict</span>
<span class="sd">            Dictionary of reference file options for use with</span>
<span class="sd">            ``get_masked_data()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;reference_type&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;reference_root&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;reference_files&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;num_reference&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="n">ref_root</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ref_files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">num_ref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_names</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;reference_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">null_split</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]:</span>
            <span class="n">data_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_root</span> <span class="k">if</span> <span class="n">null_split</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_root2</span>
            <span class="n">map_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_names</span> <span class="k">if</span> <span class="n">null_split</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_names2</span>

            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">]:</span>
                <span class="n">group1</span> <span class="o">=</span> <span class="s2">&quot;ref</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">null_split</span><span class="p">)</span>
                <span class="n">root1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s2">&quot;reference</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>

                <span class="n">files1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">map_names</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing ref</span><span class="si">{}</span><span class="s2"> map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>

                <span class="n">ref_root</span><span class="p">[</span><span class="n">group1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root1</span>
                <span class="n">ref_files</span><span class="p">[</span><span class="n">group1</span><span class="p">]</span> <span class="o">=</span> <span class="n">files1</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> reference maps in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_ref</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">[</span><span class="n">group1</span><span class="p">]),</span>
                    <span class="s2">&quot;info&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Reference files: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">files1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;reference_type&quot;</span><span class="p">:</span> <span class="n">ctype</span><span class="p">,</span>
            <span class="s2">&quot;reference_root&quot;</span><span class="p">:</span> <span class="n">ref_root</span><span class="p">,</span>
            <span class="s2">&quot;reference_files&quot;</span><span class="p">:</span> <span class="n">ref_files</span><span class="p">,</span>
            <span class="s2">&quot;num_reference&quot;</span><span class="p">:</span> <span class="n">num_ref</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="XFaster.get_files"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_files">[docs]</a>    <span class="k">def</span> <span class="nf">get_files</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_root</span><span class="p">,</span>
        <span class="n">data_subset</span><span class="o">=</span><span class="s2">&quot;full/*0&quot;</span><span class="p">,</span>
        <span class="n">signal_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">noise_subset</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
        <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;raw&quot;</span><span class="p">,</span>
        <span class="n">noise_type</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span>
        <span class="n">noise_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mask_type</span><span class="o">=</span><span class="s2">&quot;rectangle&quot;</span><span class="p">,</span>
        <span class="n">signal_type</span><span class="o">=</span><span class="s2">&quot;synfast&quot;</span><span class="p">,</span>
        <span class="n">signal_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">signal_transfer_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_root2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_subset2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">foreground_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_noise_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_type_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reference_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all files for the given data root.  The data structure is::</span>

<span class="sd">            &lt;data_root&gt;</span>
<span class="sd">                -&gt; data_&lt;data_type&gt;</span>
<span class="sd">                    -&gt; full</span>
<span class="sd">                        -&gt; map_&lt;tag&gt;.fits</span>
<span class="sd">                        ...</span>
<span class="sd">                    -&gt; 1of4 (same filenames as full)</span>
<span class="sd">                    -&gt; 2of4 (&#39;&#39;)</span>
<span class="sd">                    -&gt; 3of4 (&#39;&#39;)</span>
<span class="sd">                    -&gt; 4of4 (&#39;&#39;)</span>
<span class="sd">                -&gt; signal_&lt;signal_type&gt;</span>
<span class="sd">                   -&gt; spec_signal_&lt;signal_type&gt;.dat</span>
<span class="sd">                   -&gt; full</span>
<span class="sd">                      -&gt; map_&lt;tag&gt;_####.fits</span>
<span class="sd">                      ...</span>
<span class="sd">                   -&gt; 1of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 2of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 3of4 (same filenames as full)</span>
<span class="sd">                   -&gt; 4of4 (same filenames as full)</span>
<span class="sd">                -&gt; noise_&lt;noise_type&gt; (same filenames as signal_&lt;signal_type&gt;)</span>
<span class="sd">                -&gt; masks_&lt;mask_type&gt;</span>
<span class="sd">                    -&gt; mask_map_&lt;tag&gt;.fits</span>
<span class="sd">                    ...</span>
<span class="sd">                -&gt; foreground_&lt;foreground_type_sim&gt;</span>
<span class="sd">                    (same filenames as signal_&lt;signal_type&gt;)</span>
<span class="sd">                -&gt; templates_&lt;template_type&gt;</span>
<span class="sd">                   -&gt; template1</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                   -&gt; template2</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                -&gt; reference_&lt;reference_type&gt;</span>
<span class="sd">                   -&gt; reference1</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">                   -&gt; reference2</span>
<span class="sd">                      (same filenames as data_&lt;data_type&gt;)</span>
<span class="sd">            &lt;data_root2&gt; (If provided, same structure as data_root)</span>
<span class="sd">                ...</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        data_root : string</span>
<span class="sd">            Top level path containing subdirectories for data, signal sims,</span>
<span class="sd">            noise sims, and masks.</span>
<span class="sd">        data_subset : string</span>
<span class="sd">            Subset of maps to use for spectrum estimation.  This should be</span>
<span class="sd">            a string that is parseable using ``glob`` on the path</span>
<span class="sd">            ``data_&lt;data_type&gt;/&lt;data_subset&gt;.fits``.  For example,</span>
<span class="sd">            ``&#39;full/*0&#39;`` will expand to read in the 150 GHz and 90GHz maps.</span>
<span class="sd">            Maps are then sorted in alphabetical order, and identified</span>
<span class="sd">            by their file tag, where each filename is ``map_&lt;tag&gt;.fits``.</span>
<span class="sd">        signal_subset : string</span>
<span class="sd">            Subset of map tags to use for spectrum estimation for signal</span>
<span class="sd">            sims.  This should be a string that is parseable using ``glob``</span>
<span class="sd">            that is added onto the data_subset path to indicate which sims</span>
<span class="sd">            to use. For example, for all, use ``&#39;*&#39;``. For the first 300 sims,</span>
<span class="sd">            use ``&#39;0[0-2]*&#39;``.</span>
<span class="sd">        noise_subset : string</span>
<span class="sd">            Subset of map tags to use for spectrum estimation for noise</span>
<span class="sd">            sims.  This should be a string that is parseable using ``glob``</span>
<span class="sd">            that is added onto the data_subset path to indicate which sims</span>
<span class="sd">            to use. For example, for all, use ``&#39;*&#39;``. For the first 300 sims,</span>
<span class="sd">            use ``&#39;0[0-2]*&#39;``.</span>
<span class="sd">        data_type : string</span>
<span class="sd">            The type of data to use, default: &quot;raw&quot;</span>
<span class="sd">        noise_type: string</span>
<span class="sd">            The variant of noise simulation to use, e.g. &#39;gaussian&#39;,</span>
<span class="sd">            &#39;stationary&#39;, etc.  The directory should contain the same number</span>
<span class="sd">            of simulations for each map tag.</span>
<span class="sd">        noise_type_sim : string</span>
<span class="sd">            The variant of noise sims to use for sim_index simulated data map.</span>
<span class="sd">            This enables having a different noise sim ensemble to use for</span>
<span class="sd">            sim_index run than the ensemble from which the noise is computed.</span>
<span class="sd">        mask_type : string</span>
<span class="sd">            The variant of mask to use, e.g. &#39;rectangle&#39;, etc.</span>
<span class="sd">            We assume a mask per file tag in the mask_&lt;mask_type&gt; folder,</span>
<span class="sd">            corresponding to the files in data.</span>
<span class="sd">        signal_type : string</span>
<span class="sd">            The variant of signal simulation to use, typically identified</span>
<span class="sd">            by the input spectrum model used to generate it, e.g &#39;synfast&#39;.</span>
<span class="sd">        signal_type_sim : string</span>
<span class="sd">            The variant of signal sims to use for sim_index simulated data map.</span>
<span class="sd">            This enables having a different signal sim ensemble to use for</span>
<span class="sd">            sim_index run than the ensemble from which the signal is computed.</span>
<span class="sd">            If this is set to &#39;r&#39;, then two signal types are searched:</span>
<span class="sd">            &#39;signal_r0&#39; for a scalar component, and &#39;signal_r1tens&#39; for a tensor</span>
<span class="sd">            component.  The two maps are linearly combined with a scalar r value</span>
<span class="sd">            to construct a signal map for a simulated dataset.</span>
<span class="sd">        signal_transfer_type : string</span>
<span class="sd">            The variant of signal simulation to use for transfer function</span>
<span class="sd">            calculation, typically identified by the input spectrum model used</span>
<span class="sd">            to generate it, e.g &#39;synfast&#39;. This directory may also contain a</span>
<span class="sd">            copy of the input spectrum, to make sure that the correct spectrum</span>
<span class="sd">            is used to compute the transfer function.</span>
<span class="sd">        data_root2, data_subset2 : string</span>
<span class="sd">            The root and subset for a second set of data.  If either of these is</span>
<span class="sd">            keywords is supplied, then the two data sets are treated as two</span>
<span class="sd">            halves of a null test.  In this case, XFaster computes the sum and</span>
<span class="sd">            difference spectra for each map tag in order to estimate a null</span>
<span class="sd">            spectrum.</span>
<span class="sd">        foreground_type_sim : string</span>
<span class="sd">            Tag for directory (foreground_&lt;foreground_type_sim&gt;) where</span>
<span class="sd">            foreground sims are that should be added to the signal and noise</span>
<span class="sd">            sims when running in sim_index mode.</span>
<span class="sd">        template_type : string</span>
<span class="sd">            Tag for directory (templates_&lt;template_type&gt;) containing templates</span>
<span class="sd">            (e.g. a foreground model) to be scaled by a scalar value per map tag</span>
<span class="sd">            and subtracted from the data. The directory contains one template</span>
<span class="sd">            per map tag.</span>
<span class="sd">        template_noise_type : string</span>
<span class="sd">            Tag for directory containing template noise sims to be averaged and</span>
<span class="sd">            scaled similarly to the templates themselves.  These averaged sims</span>
<span class="sd">            are used to debias template cross spectra due to correlations in the</span>
<span class="sd">            way the noise ensembles are constructed.  Typically, this would be a</span>
<span class="sd">            noise model based on the Planck FFP10 ensemble for each half-mission</span>
<span class="sd">            foreground template.  If not supplied, this debiasing step is not</span>
<span class="sd">            performed.</span>
<span class="sd">        template_type_sim : string</span>
<span class="sd">            Tag for directory containing foreground templates, to be scaled by a</span>
<span class="sd">            scalar value per map tag and added to the simulated data.  The</span>
<span class="sd">            directory contains one template per map tag.</span>
<span class="sd">        reference_type : string</span>
<span class="sd">            If supplied, subtract a reobserved reference signal from each data</span>
<span class="sd">            map.  The reference signal maps should be two datasets with</span>
<span class="sd">            uncorrelated noise, such as Planck half-mission maps.  This option</span>
<span class="sd">            is used for removing expected signal residuals from null tests.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        file_settings : dict</span>
<span class="sd">            A dictionary of file settings used throughout the run.</span>
<span class="sd">            These are stored in full as ``&lt;output_root&gt;/files_&lt;output_tag&gt;.npz``,</span>
<span class="sd">            and a subset are added to the run configuration file</span>
<span class="sd">            ``&lt;output_root&gt;/config_&lt;output_tag&gt;.txt``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">null_run</span> <span class="o">=</span> <span class="n">data_root2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">data_subset2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">old_data_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data_subset</span><span class="o">=</span><span class="n">data_subset</span><span class="p">,</span> <span class="n">null_run</span><span class="o">=</span><span class="n">null_run</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">old_data_root2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_subset2</span><span class="o">=</span><span class="n">data_subset2</span><span class="p">)</span>

        <span class="n">alt_name</span> <span class="o">=</span> <span class="s2">&quot;files&quot;</span>

        <span class="c1"># backward compatibility</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">alt_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">!=</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">+=</span> <span class="p">[</span><span class="n">data_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">template_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;clean&quot;</span><span class="p">,</span> <span class="n">template_type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">reference_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;ref_sub&quot;</span><span class="p">]</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alt_name</span> <span class="o">==</span> <span class="n">save_name</span><span class="p">:</span>
            <span class="n">alt_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="s2">&quot;files&quot;</span><span class="p">,</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">alt_name</span><span class="o">=</span><span class="n">alt_name</span>
        <span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">update</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c1">#########################################</span>
        <span class="c1"># update configuration options (data root, map names and tags)</span>

        <span class="k">if</span> <span class="n">new</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_files</span><span class="p">(</span>
                <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">,</span>
                <span class="n">data_root</span><span class="o">=</span><span class="n">data_root</span><span class="p">,</span>
                <span class="n">data_subset</span><span class="o">=</span><span class="n">data_subset</span><span class="p">,</span>
                <span class="n">data_root2</span><span class="o">=</span><span class="n">data_root2</span><span class="p">,</span>
                <span class="n">data_subset2</span><span class="o">=</span><span class="n">data_subset2</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output_file&quot;</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;data_version&quot;</span><span class="p">)</span>

            <span class="c1"># fix data root</span>
            <span class="k">if</span> <span class="n">data_root</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">]:</span>
                <span class="n">old_data_root</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">]</span>
                <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_root</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_root2</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root2&quot;</span><span class="p">]:</span>
                    <span class="n">old_data_root2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root2&quot;</span><span class="p">]</span>
                    <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_root2</span>

        <span class="c1"># update configuration attributes for later use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_root</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_subset</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_subset&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_names</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;map_names&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="o">=</span> <span class="n">null_run</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_root2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_root2&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_subset2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_subset2&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_names2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;map_names2&quot;</span><span class="p">]</span>

        <span class="c1">#########################################</span>
        <span class="c1"># update mask files</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;mask_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask_type</span><span class="p">:</span>
            <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mask_files</span><span class="p">(</span><span class="n">mask_type</span><span class="p">))</span>

        <span class="c1">#########################################</span>
        <span class="c1"># update sim options</span>

        <span class="k">if</span> <span class="n">signal_transfer_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_transfer_type</span> <span class="o">=</span> <span class="n">signal_type</span>

        <span class="c1"># make sure sims get rerun correctly</span>
        <span class="k">if</span> <span class="n">signal_transfer_type</span> <span class="o">==</span> <span class="n">signal_type</span><span class="p">:</span>
            <span class="c1"># if signal types match, then sims are run before computing the</span>
            <span class="c1"># transfer function, so need to set the correct checkpoint to rerun</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">==</span> <span class="s2">&quot;sims&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">=</span> <span class="s2">&quot;sims_transfer&quot;</span>

        <span class="n">ret1</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">new</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;signal_transfer_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signal_transfer_type</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;signal_subset&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signal_subset</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sims_transfer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span>
                    <span class="s2">&quot;signal_transfer&quot;</span><span class="p">,</span> <span class="n">signal_transfer_type</span><span class="p">,</span> <span class="n">signal_subset</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">new</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;signal_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signal_type</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;signal_subset&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signal_subset</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sims&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span><span class="s2">&quot;signal&quot;</span><span class="p">,</span> <span class="n">signal_type</span><span class="p">,</span> <span class="n">signal_subset</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">new</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;noise_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">noise_type</span>
            <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;noise_subset&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">noise_subset</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sims&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_files</span><span class="p">(</span><span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="n">noise_type</span><span class="p">,</span> <span class="n">noise_subset</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret1</span><span class="p">):</span>
            <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ret1</span><span class="p">)</span>

        <span class="c1">#########################################</span>
        <span class="c1"># update data options</span>

        <span class="k">if</span> <span class="n">signal_type_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal_type_sim</span> <span class="o">=</span> <span class="n">signal_type</span>
        <span class="k">if</span> <span class="n">noise_type_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise_type_sim</span> <span class="o">=</span> <span class="n">noise_type</span>
        <span class="k">if</span> <span class="n">template_type_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_type_sim</span> <span class="o">=</span> <span class="n">template_type</span>

        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">template_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">template_noise_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">template_type_sim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reference_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ret1</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># update data files</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;data_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">data_type</span><span class="p">:</span>
            <span class="c1"># no need to force rerun since data filenames track data type</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_data_files</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">))</span>

        <span class="c1"># update template files</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;template_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">template_type</span><span class="p">:</span>
            <span class="c1"># no need to force rerun since data filenames track template type</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_template_files</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="n">template_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;template_noise_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">template_noise_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;template_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sim_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_template_files</span><span class="p">(</span><span class="s2">&quot;template_noise&quot;</span><span class="p">,</span> <span class="n">template_noise_type</span><span class="p">))</span>

        <span class="c1"># update reference files for null tests</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;reference_type&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">reference_type</span><span class="p">:</span>
            <span class="c1"># no need to force rerun since data filenames track reference type</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_reference_files</span><span class="p">(</span><span class="n">reference_type</span><span class="p">))</span>

        <span class="c1"># update sim data files</span>
        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;signal_type_sim&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signal_type_sim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sim_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_data_files</span><span class="p">(</span><span class="s2">&quot;signal&quot;</span><span class="p">,</span> <span class="n">signal_type_sim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;noise_type_sim&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">noise_type_sim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sim_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_data_files</span><span class="p">(</span><span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="n">noise_type_sim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;foreground_type_sim&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">foreground_type_sim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sim_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_data_files</span><span class="p">(</span><span class="s2">&quot;foreground&quot;</span><span class="p">,</span> <span class="n">foreground_type_sim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">new</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;template_type_sim&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">template_type_sim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sim_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sim_data_files</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="n">template_type_sim</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret1</span><span class="p">):</span>
            <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ret1</span><span class="p">)</span>

        <span class="c1">#########################################</span>
        <span class="c1"># final consistency checks</span>

        <span class="c1"># check that file counts match</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;num_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;2&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;2&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">:</span>
                <span class="n">ftype</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">2 files, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">ftype</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># update data roots if necessary</span>
        <span class="k">if</span> <span class="n">old_data_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">null_run</span> <span class="ow">and</span> <span class="n">old_data_root2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;template&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">old_data_root2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">old_data_root2</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">v</span>
                    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root2</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">old_data_root2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">old_data_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">old_data_root</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_root</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">old_data_root</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">varr</span> <span class="o">=</span> <span class="p">[</span><span class="n">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vv</span><span class="p">)</span> <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">varr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">varr</span> <span class="o">=</span> <span class="p">[</span><span class="n">replace_root</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">vvv</span><span class="p">)</span> <span class="k">for</span> <span class="n">vvv</span> <span class="ow">in</span> <span class="n">vv</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">varr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># update all attributes</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="XFaster.get_map"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">check_nside</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an input map from file or from an internal cache.  Maps are</span>
<span class="sd">        checked to make sure they all have a consistent size, and optionally</span>
<span class="sd">        cached to limit disk I/O.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Path to file on disk.</span>
<span class="sd">        check_nside : bool</span>
<span class="sd">            If True (default), make sure that all maps have the same ``nside``,</span>
<span class="sd">            and that it satisfies ``lmax &lt;= 4 * nside``.</span>
<span class="sd">        cache : bool</span>
<span class="sd">            If True, cache the map in memory to avoid rereading from disk.</span>
<span class="sd">            Use this for maps that are used multiple times by the algoritm</span>
<span class="sd">            (e.g. masks).</span>

<span class="sd">        Any remaining arguments are passed to ``healpy.read_map``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : array_like</span>
<span class="sd">            2D map array containing 1 (T) or 3 (T/Q/U) maps.</span>
<span class="sd">            If the XFaster class was initialized with ``pol = True``, this</span>
<span class="sd">            returns a 2D array of T/Q/U maps from the file. Otherwise a</span>
<span class="sd">            (1, npix) array is returned containing only the T map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="c1"># initialize map cache</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_map_cache&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;reset&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># return a copy from cache if found</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">and</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">])</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;field&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Reading map from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="n">m</span><span class="p">[</span><span class="n">hp</span><span class="o">.</span><span class="n">mask_bad</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">check_nside</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># check nside</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">get_nside</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="n">nside</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nside</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Input map </span><span class="si">{}</span><span class="s2"> has nside </span><span class="si">{}</span><span class="s2"> expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">filename</span><span class="p">,</span> <span class="n">nside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># check npix</span>
            <span class="n">npix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">nside2npix</span><span class="p">(</span><span class="n">nside</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;npix&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="n">npix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">npix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Input map </span><span class="si">{}</span><span class="s2"> has npix </span><span class="si">{}</span><span class="s2"> expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">filename</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># check lmax</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;lmax </span><span class="si">{}</span><span class="s2"> may be too large for nside </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map_cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.get_mask"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_lims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an input mask from file or from an internal cache.</span>
<span class="sd">        See ``XFaster.get_map`` for details.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Path to mask file on disk.</span>
<span class="sd">        cache : bool</span>
<span class="sd">            This option defaults to True, since masks are typically used</span>
<span class="sd">            for all data and sims for a given map tag.</span>
<span class="sd">        check_lims : bool</span>
<span class="sd">            If True, values in the mask outside of [0,1] are fixed to</span>
<span class="sd">            these limits.</span>

<span class="sd">        Any remaining arguments are passed to ``XFaster.get_map``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : array_like</span>
<span class="sd">            2D array containing 1 (T) or 2 (T/P) maps;  If the XFaster class</span>
<span class="sd">            was initialized with ``pol_mask = True``, this returns a 2D array</span>
<span class="sd">            containing both T and P masks.  Otherwise, a (1, npix) is</span>
<span class="sd">            returned containing only the T map.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fields_mask</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;field&quot;</span><span class="p">,</span> <span class="n">fields_mask</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_lims</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.get_filename"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_filename">[docs]</a>    <span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iter_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_opts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bp_opts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a standard output file path to read or write.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            String name of output type.  E.g. &#39;data_xcorr&#39; for data</span>
<span class="sd">            cross-correlation spectra.</span>
<span class="sd">            If an output tag is set, the name is appended with</span>
<span class="sd">            &#39;_&lt;output_tag&gt;&#39;.</span>
<span class="sd">        ext : string</span>
<span class="sd">            File extension.  The default (&#39;.npz&#39;) is used for storing</span>
<span class="sd">            output data dictionaries.</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If supplied, the name is appended with &#39;_map_&lt;map_tag&gt;&#39;.</span>
<span class="sd">            Use this argument when storing output data in a loop over</span>
<span class="sd">            input maps.</span>
<span class="sd">        iter_index : int</span>
<span class="sd">            If supplied, the name is appended with &#39;_iter&lt;iter_index&gt;&#39;.</span>
<span class="sd">        extra_tag : string</span>
<span class="sd">            If supplied the extra tag is appended to the name as is.</span>
<span class="sd">        data_opts : bool</span>
<span class="sd">            If True, the output filename is constructed by checking the</span>
<span class="sd">            following list of options used in constructing data cross-spectra:</span>
<span class="sd">            ensemble_mean, ensemble_median, sim_index, sim_type, data_type,</span>
<span class="sd">            template_cleaned, reference_type.</span>
<span class="sd">        bp_opts : bool</span>
<span class="sd">            If True, also check the following attributes (in addition to those</span>
<span class="sd">            checked if ``data_opts`` is True): weighted_bins, return_cls.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Output filename as ``&lt;output_root&gt;/&lt;name&gt;&lt;ext&gt;``, where</span>
<span class="sd">            &lt;name&gt; is constructed from the above set of options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data_opts</span> <span class="ow">or</span> <span class="n">bp_opts</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ensemble_mean&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;sim_mean&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ensemble_median&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;sim_median&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sim_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;sim&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">,</span> <span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="s2">&quot;foreground&quot;</span><span class="p">,</span> <span class="s2">&quot;template&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_type</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_type</span><span class="p">[</span><span class="n">comp</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}{:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span><span class="p">[</span><span class="n">comp</span><span class="p">])]</span>
                        <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;signal&quot;</span> <span class="ow">and</span> <span class="s2">&quot;tensor&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span><span class="p">:</span>
                            <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;t</span><span class="si">{:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span><span class="p">[</span><span class="s2">&quot;tensor&quot;</span><span class="p">])]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span> <span class="o">!=</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;clean&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;reference_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;ref&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bp_opts</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;wbins&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;return_cls&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cl&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">iter_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;iter</span><span class="si">{:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_index</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">extra_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="n">extra_tag</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_tag</span><span class="p">]</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ext</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFaster.force_rerun_children"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.force_rerun_children">[docs]</a>    <span class="k">def</span> <span class="nf">force_rerun_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checkpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trigger rerunning steps that depend on this checkpoint.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint_tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="XFaster.load_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.load_data">[docs]</a>    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">checkpoint</span><span class="p">,</span>
        <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alt_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">optional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">file_opts</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load xfaster data from an output.npz file on disk.</span>

<span class="sd">        This method is called throughout the code at various checkpoints.  If</span>
<span class="sd">        the data exist on disk, they are loaded and returned.  If the data are</span>
<span class="sd">        missing or otherwise incompatible, they are recomputed by the corresponding</span>
<span class="sd">        calling method, and trigger all subsequent data to also be recomputed.  Data</span>
<span class="sd">        handling is described in the ``Notes`` section for methods that use this</span>
<span class="sd">        functionality.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the data set.  The filename is contructed from this</span>
<span class="sd">            as ``&lt;output_root&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``.  If the file is not</span>
<span class="sd">            found then the data are recomputed.</span>
<span class="sd">        checkpoint : string</span>
<span class="sd">            The name of the checkpoint to which this dataset applies.</span>
<span class="sd">            If XFaster is initialized at this checkpoint, or if any of the</span>
<span class="sd">            file checks enabled with the following options fails, all</span>
<span class="sd">            quantities from this point forward are recomputed.</span>
<span class="sd">        fields : list of strings</span>
<span class="sd">            List of fields that should be present in the data file.</span>
<span class="sd">            If any are not found, the entire dataset and all subsequent</span>
<span class="sd">            step are recomputed.</span>
<span class="sd">        to_attrs : bool or list of bools or strings</span>
<span class="sd">            If True, all items in ``fields`` are stored as attributes of the</span>
<span class="sd">            parent object. If A list of booleans, must have the same length</span>
<span class="sd">            as ``fields``; any field for which this list item is True is then</span>
<span class="sd">            stored as an attribute of the object.  If any list item is a string,</span>
<span class="sd">            then the corresponding field is stored as an attribute with this</span>
<span class="sd">            new name.</span>
<span class="sd">        shape : tuple of ints</span>
<span class="sd">            If set, the field specified by ``shape_ref`` is checked to have this</span>
<span class="sd">            shape.  If this check fails, then all data are recomputed.</span>
<span class="sd">        shape_ref : string</span>
<span class="sd">            The reference field whose shape is checked against ``shape``.</span>
<span class="sd">            If None and ``shape`` is set, use the first field in ``fields``.</span>
<span class="sd">        alt_name : string</span>
<span class="sd">            Alternative to ``name`` argument that will be read if file matching</span>
<span class="sd">            ``name`` doesn&#39;t exist.</span>
<span class="sd">        value_ref : dict</span>
<span class="sd">            Dictionary of reference values that is checked if simply loading a</span>
<span class="sd">            file from disk instead of recomputing-- forces rerun of checkpoints</span>
<span class="sd">            if loaded dictionary differs from value_ref.</span>
<span class="sd">        optional : list of strings</span>
<span class="sd">            Fields that, if missing from the data loaded from disk, will not</span>
<span class="sd">            trigger force rerunning of any checkpoints.</span>


<span class="sd">        Remaining options are passed to ``get_filename`` for constructing the</span>
<span class="sd">        output file path.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            If all checks above succeed, the requested data are returned.</span>
<span class="sd">            If any tests fail, None is returned, and all subsequent calls</span>
<span class="sd">            to ``load_data`` also return None to trigger recomputing all data</span>
<span class="sd">            that may depend on this dataset.</span>
<span class="sd">            The output dictionary has the additional key &#39;output_file&#39; which</span>
<span class="sd">            is set to the path to the data file on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># checkpointing</span>
        <span class="k">if</span> <span class="n">checkpoint</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid checkpoint </span><span class="si">{}</span><span class="s2">, must be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">checkpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoint</span> <span class="o">==</span> <span class="n">checkpoint</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">checkpoint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">checkpoint</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>

        <span class="n">use_alt</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Error loading </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_file</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: File not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">alt_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">alt_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Error loading </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_file</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Alternate file not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">use_alt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">fields</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">shape_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape_ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">shape_ref</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_attrs</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">to_attrs</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">to_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_attrs</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">value_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_ref</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value_ref</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">to_attrs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">optional</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">optional</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">field</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">shape_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                    <span class="c1"># check if it&#39;s just an extra dimension, ie (1,500) vs (500,)</span>
                    <span class="n">passes</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">passes</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">passes</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> has shape </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">errmsg</span><span class="p">,</span> <span class="n">shape_ref</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">field</span><span class="p">,</span> <span class="n">attr</span><span class="p">]:</span>
                    <span class="n">vref</span> <span class="o">=</span> <span class="n">value_ref</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;undef&quot;</span><span class="p">)</span>
                    <span class="c1"># turn it into an array if possible to compare</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">vref</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">vref</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>

                    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">vref</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;undef&quot;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">vref</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Field </span><span class="si">{}</span><span class="s2"> has value </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">errmsg</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">vref</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">attr</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">field</span> <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">attr</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;output_file&quot;</span><span class="p">,</span> <span class="s2">&quot;data_version&quot;</span><span class="p">]:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ret</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">value_ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Missing reference fields </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">value_ref</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Loaded input data from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_alt</span><span class="p">:</span>
            <span class="c1"># copy data to original file name</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">file_opts</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;output_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_file</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="XFaster.save_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save xfaster data to an output .npz file on disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        name : string</span>
<span class="sd">            The name of the data set.  The filename is contructed from this as</span>
<span class="sd">            ``&lt;output_root&gt;/&lt;name&gt;_&lt;output_tag&gt;.npz``.  If the file is not found</span>
<span class="sd">            then the data are recomputed.</span>
<span class="sd">        from_attrs : list of strings</span>
<span class="sd">            A list of object attributes which should be stored in the data file.</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            Load the dataset corresponding to this map.</span>
<span class="sd">            See ``get_filename`` for documentation.</span>
<span class="sd">        iter_index : int</span>
<span class="sd">            Load the dataset corresponding to this iteration index.</span>
<span class="sd">            See ``get_filename`` for documentation.</span>
<span class="sd">        bp_opts : bool</span>
<span class="sd">            Format output bandpowers file.  See ``get_filename`` for</span>
<span class="sd">            documentation.</span>
<span class="sd">        extra_tag : str</span>
<span class="sd">             Tag to add to file name.</span>

<span class="sd">        Any remaining keyword arguments are added to the output dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            A copy of the data dictionary that was stored to disk.</span>
<span class="sd">            The output dictionary has the additional key &#39;output_file&#39; which</span>
<span class="sd">            is set to the path to the data file on disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;data_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_version</span>

        <span class="n">file_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;map_tag&quot;</span><span class="p">,</span> <span class="s2">&quot;iter_index&quot;</span><span class="p">,</span> <span class="s2">&quot;data_opts&quot;</span><span class="p">,</span> <span class="s2">&quot;bp_opts&quot;</span><span class="p">,</span> <span class="s2">&quot;extra_tag&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">file_opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>

        <span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.npz&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">file_opts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_file</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">from_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Saved output data to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_file</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;output_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_file</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="XFaster.save_config"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.save_config">[docs]</a>    <span class="k">def</span> <span class="nf">save_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a configuration file for the current run on disk.</span>
<span class="sd">        This method is used by ``xfaster_run`` to store the config</span>
<span class="sd">        in ``&lt;output_root&gt;/config_&lt;output_tag&gt;.txt``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cfg : XFasterConfig or RawConfigParser object</span>
<span class="sd">            Config object containing all relevant arguments to save to disk.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of the config file saved to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">XFasterConfig</span><span class="p">):</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">XFasterConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">creator</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getlogin</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="n">creator</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;# Created by </span><span class="si">{}</span><span class="s2"> on {:%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">creator</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filename</span></div>

<div class="viewcode-block" id="XFaster.apply_mask"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.apply_mask">[docs]</a>    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the input mask to the data map, in place.</span>

<span class="sd">        If the map is polarized, the appropriate mask is applied</span>
<span class="sd">        to the polarization data, depending on whether the mask</span>
<span class="sd">        is also polarized.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m : array_like</span>
<span class="sd">            Input map (T/Q/U if polarized, T-only if not)</span>
<span class="sd">            This array is modified in place.</span>
<span class="sd">        mask : array_like</span>
<span class="sd">            Mask to apply (T/P if polarized, T-only if not)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m : array_like</span>
<span class="sd">            Input map multiplied by mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="XFaster.map2alm"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.map2alm">[docs]</a>    <span class="k">def</span> <span class="nf">map2alm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for healpy.map2alm.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m : array_like</span>
<span class="sd">            Masked input map for which spherical harmonic alms are</span>
<span class="sd">            computed.</span>
<span class="sd">        pol : bool</span>
<span class="sd">            If None, this is set using the value with which the object</span>
<span class="sd">            was initialized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alms : array_like</span>
<span class="sd">            Alms for the input map, computed using the equivalent of</span>
<span class="sd">            ``healpy.map2alm (m, lmax, pol=self.pol, use_weights=True)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="n">pol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pol</span><span class="p">,</span> <span class="n">use_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="XFaster.alm2cl"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.alm2cl">[docs]</a>    <span class="k">def</span> <span class="nf">alm2cl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for healpy.alm2cl.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        m1 : array_like</span>
<span class="sd">            Masked alms for map1</span>
<span class="sd">        m2 : array_like</span>
<span class="sd">            Masked alms for map2</span>
<span class="sd">        lmin : int, default: 2</span>
<span class="sd">            The minimum ell bin to include in the output Cls.  All ell</span>
<span class="sd">            bins below this are nulled out.</span>
<span class="sd">        lmax : int</span>
<span class="sd">            The maximum ell bin to compute.  If None, this is set to the</span>
<span class="sd">            lmax value with which the class was initialized.</span>
<span class="sd">        symmetric : bool, default: True</span>
<span class="sd">            If True, the average cross spectrum of (m1-x-m2 + m2-x-m1) / 2.</span>
<span class="sd">            is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : array_like</span>
<span class="sd">            Cross-spectrum of m1-x-m2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="k">if</span> <span class="n">lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">alms2</span><span class="o">=</span><span class="n">m2</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
            <span class="n">cls_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">alms2</span><span class="o">=</span><span class="n">m1</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">))</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span> <span class="o">+</span> <span class="n">cls_T</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="n">lmin</span><span class="p">:</span>
            <span class="bp">cls</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">lmin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_mask_weights"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_mask_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_mask_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reload_gcorr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gcorr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cross spectra of the masks for each data map.</span>

<span class="sd">        Mode counting matrices are also computed and stored for each mask.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        apply_gcorr : bool</span>
<span class="sd">            If True, a correction factor is applied to the g (mode counting)</span>
<span class="sd">            matrix.  The correction factor should have been pre-computed for</span>
<span class="sd">            each map tag using independent scripts in the code package.</span>
<span class="sd">        reload_gcorr : bool</span>
<span class="sd">            If True, reload the gcorr file from the masks directory. Useful when</span>
<span class="sd">            iteratively solving for the correction terms.</span>
<span class="sd">        gcorr_file : str</span>
<span class="sd">            If not None, path to gcorr file. Otherwise, use file labeled</span>
<span class="sd">            mask_map_&lt;tag&gt;_gcorr.npz in mask directory for signal, or</span>
<span class="sd">            mask_map_&lt;tag&gt;_gcorr_null.npz for nulls.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;masks&#39; checkpoint, loads or saves a</span>
<span class="sd">        data dictionary with the following keys:</span>

<span class="sd">            wls:</span>
<span class="sd">                mask1-x-mask2 mask cross spectra for every mask pair</span>
<span class="sd">            fsky, w1, w2, w4:</span>
<span class="sd">                sky fraction and weighted modes per mask product</span>
<span class="sd">            gmat:</span>
<span class="sd">                mode-counting matrix, computed from ``g = fsky * w2 ** 2 / w4``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">mask_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_shape</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;wls&quot;</span><span class="p">,</span> <span class="s2">&quot;fsky&quot;</span><span class="p">,</span> <span class="s2">&quot;w1&quot;</span><span class="p">,</span> <span class="s2">&quot;w2&quot;</span><span class="p">,</span> <span class="s2">&quot;w4&quot;</span><span class="p">,</span> <span class="s2">&quot;gmat&quot;</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">,</span> <span class="s2">&quot;npix&quot;</span><span class="p">,</span> <span class="s2">&quot;gcorr&quot;</span><span class="p">]</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;masks_xcorr&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;masks&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">],</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">mask_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;wls&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file_in</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;gcorr&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">apply_gcorr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">mfile</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">reload_gcorr</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">gcorr_file_in</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
                        <span class="n">gcorr_file</span> <span class="o">=</span> <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_gcorr_null.npz&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gcorr_file</span> <span class="o">=</span> <span class="n">mfile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_gcorr.npz&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gcorr_file</span> <span class="o">=</span> <span class="n">gcorr_file_in</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;G correction file </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="n">gdata</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>
                <span class="n">gcorr</span> <span class="o">=</span> <span class="n">gdata</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gcorr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># check bins match g</span>
                    <span class="n">bd0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="n">gdata</span><span class="p">[</span><span class="s2">&quot;bin_def&quot;</span><span class="p">][</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
                        <span class="n">bd</span> <span class="o">=</span> <span class="n">bd</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd0</span><span class="p">)]</span>
                        <span class="n">gcorr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bd0</span> <span class="o">==</span> <span class="n">bd</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;G correction for map </span><span class="si">{}</span><span class="s2"> has incompatible bin def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">tag</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Found g correction for map </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">gcorr</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">gcorr</span>

            <span class="c1"># compute ell-by-ell mode counting factor</span>
            <span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ellfac</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">ell</span> <span class="o">+</span> <span class="mf">1.0</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                    <span class="n">gcorr0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">m0</span><span class="p">]</span>
                    <span class="n">gcorr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">*</span> <span class="n">ellfac</span>
                    <span class="k">if</span> <span class="n">apply_gcorr</span><span class="p">:</span>
                        <span class="n">gcorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gcorr0</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">*</span> <span class="n">gcorr1</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span>
                        <span class="k">for</span> <span class="n">gc</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gcorr</span><span class="p">,</span> <span class="n">bd</span><span class="p">):</span>
                            <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">*=</span> <span class="n">gc</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span> <span class="o">=</span> <span class="n">apply_gcorr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">gmat_ell</span>

        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">apply_gcorr</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reload_gcorr</span> <span class="ow">or</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gcorr&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;gcorr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gcorr</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># mask spectra</span>
        <span class="n">wls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># moments</span>
        <span class="n">fsky</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">fsky_eff</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">w4</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A internal convenience function computes/loads alms from/to cache for each mask idx.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing Alms for mask </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">mask_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_alms</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">spec_inds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tt&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="s2">&quot;ee&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;bb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;te&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="s2">&quot;eb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;tb&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">imask_alms</span><span class="p">,</span> <span class="n">imask</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">jmask_alms</span><span class="p">,</span> <span class="n">jmask</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing mask spectra </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">wls</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imask_alms</span><span class="p">,</span> <span class="n">jmask_alms</span><span class="p">,</span> <span class="n">lmin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span><span class="p">:</span>
                <span class="c1"># If there is a pol mask in addition to I, copy it to</span>
                <span class="c1"># U so no I masks is [I, Q, U] instead of [I, pol]</span>
                <span class="n">imask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">imask</span><span class="p">,</span> <span class="n">imask</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">jmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">jmask</span><span class="p">,</span> <span class="n">jmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># calculate moments of cross masks</span>
            <span class="c1"># this is an array of shape (pol_dim, pol_dim, npix)</span>
            <span class="c1"># and contains all combinations of mask products</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i...,j...-&gt;ij...&quot;</span><span class="p">,</span> <span class="n">imask</span><span class="p">,</span> <span class="n">jmask</span><span class="p">))</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># fsky is the fraction of pixels that are nonzero, independent</span>
            <span class="c1"># of weight</span>
            <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span>
            <span class="n">w1</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="n">w2</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="n">w4</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span> <span class="o">**</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">counts</span>
            <span class="c1"># effective fsky takes into account weights between 0 and 1</span>
            <span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">w2</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">/</span> <span class="n">w4</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">fsky</span><span class="p">[</span><span class="n">xname</span><span class="p">])</span>  <span class="c1"># second order correction</span>
            <span class="p">)</span>

            <span class="c1"># compute gmat as the average fsky_eff assuming symmetrically</span>
            <span class="c1"># computed cross spectra, e.g. TE = (T1 * E2 + T2 * E1) / 2</span>
            <span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">si</span><span class="p">,</span> <span class="n">sj</span> <span class="o">=</span> <span class="n">spec_inds</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">]</span> <span class="o">+</span> <span class="n">fsky_eff</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sj</span><span class="p">,</span> <span class="n">si</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">gmat</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fsky</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Some fsky are larger than 10</span><span class="si">% - s</span><span class="s2">econd order &quot;</span>
                <span class="s2">&quot;correction may break down here: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fsky</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># store and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wls</span> <span class="o">=</span> <span class="n">wls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsky</span> <span class="o">=</span> <span class="n">fsky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w1</span> <span class="o">=</span> <span class="n">w1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w2</span> <span class="o">=</span> <span class="n">w2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w4</span> <span class="o">=</span> <span class="n">w4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gmat</span> <span class="o">=</span> <span class="n">gmat</span>

        <span class="n">process_gcorr</span><span class="p">(</span><span class="n">gcorr_file</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Fsky: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fsky</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Effective fsky: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fsky_eff</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 1: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 2: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w2</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Mask moments 4: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w4</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;G matrix: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gmat</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_noise_residuals"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_noise_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">get_noise_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of ell-by-ell noise residual spectra from an output</span>
<span class="sd">        bandpowers file, to be applied to noise Alm&#39;s using ``healpy.almxfl``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">load_and_parse</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;bin_def&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span> <span class="n">map_tag</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">specs</span><span class="p">))]</span>

            <span class="n">res_qb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
            <span class="p">(</span><span class="n">bad</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res_qb</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unphysical residuals fit, nulling </span><span class="si">{}</span><span class="s2"> bins </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bad</span><span class="p">))</span>
                <span class="n">res_qb</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">rl</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">expand_qb</span><span class="p">(</span><span class="n">res_qb</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rls</span><span class="p">:</span>
                <span class="n">rls</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">rls</span><span class="p">[</span><span class="n">map_tag</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">rl</span>

        <span class="k">return</span> <span class="n">rls</span></div>

<div class="viewcode-block" id="XFaster.get_masked_data"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">template_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ensemble_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ensemble_median</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">components</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">,</span> <span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="s2">&quot;foreground&quot;</span><span class="p">],</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">qb_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">template_alpha_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">save_sim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute cross spectra of the data maps.</span>

<span class="sd">        Map and mask files must have been loaded in by calling the ``get_files``</span>
<span class="sd">        method with the appropriate file selection options.</span>

<span class="sd">        If only one dataset is selected, spectra are computed for every</span>
<span class="sd">        combination of pairs of data maps. This results in N * (N + 1) / 2</span>
<span class="sd">        cross spectra for N maps. A unique mask is used for each input map.</span>

<span class="sd">        If two datasets are selected for a null test, then sum and difference cross-spectra are</span>
<span class="sd">        computed by summing and differencing the two datasets.  A unique mask is</span>
<span class="sd">        used for each map in the first dataset, and the same mask is applied to</span>
<span class="sd">        the corresponding map in the second dataset, so that both halves are</span>
<span class="sd">        masked identically.</span>

<span class="sd">        If ``template_alpha`` is supplied, the values given are applied to an</span>
<span class="sd">        appropriate template, and the result is subtracted from the data alms</span>
<span class="sd">        with map tags in the dictionary.  Map alms are cached to speed up</span>
<span class="sd">        processing, if this method is called repeatedly with different values.</span>

<span class="sd">        The remaining options handle subtraction of additional biases from the</span>
<span class="sd">        data, or constructing simulated datasets from sim ensembles.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        template_alpha : dict</span>
<span class="sd">            Dictionary of template scaling factors to apply to foreground</span>
<span class="sd">            templates to be subtracted from the data.  Keys should match</span>
<span class="sd">            original map tags in the data set.</span>
<span class="sd">        template_specs : list</span>
<span class="sd">            Which spectra to use for alpha in the likelihood.</span>
<span class="sd">        ensemble_mean : bool</span>
<span class="sd">            If True, use the mean of the ``signal_type`` and ``noise_type``</span>
<span class="sd">            ensembles, rather than using maps from the ``data_type`` directory</span>
<span class="sd">            or any other sim options.  This is useful for testing the behavior</span>
<span class="sd">            of the estimator and mapmaker independently of the data.</span>
<span class="sd">        ensemble_median : bool</span>
<span class="sd">            If True, use the median of the ``signal_type`` and ``noise_type``</span>
<span class="sd">            ensembles, rather than using maps from the ``data_type`` directory</span>
<span class="sd">            or any other sim options.  This is useful for testing the behavior</span>
<span class="sd">            of the estimator and mapmaker independently of the data.</span>
<span class="sd">        sim : bool</span>
<span class="sd">            If True, construct simulated data maps using the options below.</span>
<span class="sd">        components : list of strings</span>
<span class="sd">            List of components to include in the simulated data, of signal,</span>
<span class="sd">            noise, foreground or template.</span>
<span class="sd">        index : int or dict</span>
<span class="sd">            If supplied and ``sim`` is True, then simulated data maps are</span>
<span class="sd">            constructed from the appropriate index from the sim ensembles</span>
<span class="sd">            ``signal_type_sim``, ``noise_type_sim`` and/or</span>
<span class="sd">            ``foreground_type_sim``, rather than using maps from the</span>
<span class="sd">            ``data_type`` directory.  If an integer, then the same index is used</span>
<span class="sd">            for all ensembles.  Otherwise, should be a dictionary keyed by</span>
<span class="sd">            component (signal, tensor, noise, foreground).  Additionally, the key</span>
<span class="sd">            ``default`` can be used to indicate the index to use for components</span>
<span class="sd">            that are not explicitly enumerated in the dictionary.  If not</span>
<span class="sd">            supplied, and ``sim`` is True, index 0 is used for all ensembles.</span>
<span class="sd">        r : float</span>
<span class="sd">            If supplied, the simulated signal maps are constructed by combining</span>
<span class="sd">            ``signal_scalar + r * signal_tensor``, where the scalar maps are</span>
<span class="sd">            stored in the directory ``signal_root_sim``, and the tensor maps are</span>
<span class="sd">            stored in the directory ``tensor_root_sim``.  A separate sim index</span>
<span class="sd">            is assumed for the ``signal`` (scalar) ensemble and the ``tensor``</span>
<span class="sd">            ensemble.</span>
<span class="sd">        qb_file : str</span>
<span class="sd">            If supplied and noise is included in ``components``, correct the</span>
<span class="sd">            simulated noise spectra using the noise residuals stored in this</span>
<span class="sd">            file.  Typically, this is the output of a separate data run used to</span>
<span class="sd">            determine the appropriate noise correction.  See</span>
<span class="sd">            ``get_noise_residuals`` for more details.</span>
<span class="sd">        template_alpha_sim : dict</span>
<span class="sd">            Dictionary of template scaling factors to apply to foreground</span>
<span class="sd">            templates to be added to the simulated the data.  Keys should match</span>
<span class="sd">            original map tags in the data set.</span>
<span class="sd">        save_sim : bool</span>
<span class="sd">            If True and constructing a simulated dataset using any of the above</span>
<span class="sd">            sim options, write the simulated dataset to disk using an</span>
<span class="sd">            appropriate ``&#39;data_xcorr.npz&#39;`` filename.  If False, only</span>
<span class="sd">            non-simulated datasets are written to disk.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;data&#39; checkpoint, loads or saves a data</span>
<span class="sd">        dictionary with the following spectra:</span>

<span class="sd">            cls_data:</span>
<span class="sd">                map1-x-map2 cross spectra for every map pair. This contains the</span>
<span class="sd">                sum cross spectra if constructing a null test.</span>
<span class="sd">            cls_data_clean:</span>
<span class="sd">                template-subtracted spectra, if ``template_alpha`` is supplied.</span>
<span class="sd">            cls_template:</span>
<span class="sd">                template cross spectra necessary to rebuild the</span>
<span class="sd">                template-subtracted data when the ``template_alpha`` parameter</span>
<span class="sd">                is changed.</span>
<span class="sd">            cls_data_null:</span>
<span class="sd">                (map1a-map1b)-x-(map2a-map2b) difference cross spectra for every</span>
<span class="sd">                map pair, if computing a null test</span>
<span class="sd">            cls_ref, cls_ref_null:</span>
<span class="sd">                reference cross spectra, if ``reference_type`` is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="n">null_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span>

        <span class="k">if</span> <span class="n">template_specs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span>

        <span class="c1"># ensure dictionary</span>
        <span class="k">if</span> <span class="n">template_alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">null_run</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensure tagged by original tags</span>
            <span class="n">template_alpha</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># set sim attributes</span>
        <span class="k">if</span> <span class="n">ensemble_mean</span> <span class="ow">or</span> <span class="n">ensemble_median</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ensemble_mean</span><span class="p">:</span>
                <span class="n">cls_ens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim</span>
                <span class="n">cls_ens_null</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">ensemble_median</span><span class="p">:</span>
                <span class="n">cls_ens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_med</span>
                <span class="n">cls_ens_null</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_med_null</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">sim_type</span> <span class="o">=</span> <span class="n">components</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="n">r</span> <span class="o">=</span> <span class="n">qb_file</span> <span class="o">=</span> <span class="n">template_alpha_sim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">sim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">default_index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">sim_type</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">null_run</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_type_sim</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;template&quot;</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="n">components</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;signal&quot;</span><span class="p">,</span> <span class="s2">&quot;noise&quot;</span><span class="p">,</span> <span class="s2">&quot;foreground&quot;</span><span class="p">,</span> <span class="s2">&quot;template&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;signal&quot;</span><span class="p">:</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
                        <span class="n">qb_file</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;template&quot;</span><span class="p">:</span>
                        <span class="n">template_alpha_sim</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">continue</span>
                <span class="n">root</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_root_sim&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing </span><span class="si">{}</span><span class="s2"> sim files&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;signal&quot;</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_root_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing tensor signal sim files&quot;</span><span class="p">)</span>
                    <span class="n">sim_type</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rp</span><span class="si">{:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;tensor&quot;</span><span class="p">,</span> <span class="n">default_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sim_type</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_type_sim&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;template&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">template_alpha_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">template_alpha_sim</span> <span class="o">=</span> <span class="n">template_alpha</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">template_alpha_sim</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">template_alpha_sim</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">default_index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_mean</span> <span class="o">=</span> <span class="n">ensemble_mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_median</span> <span class="o">=</span> <span class="n">ensemble_median</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_type</span> <span class="o">=</span> <span class="n">sim_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_index</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Check for output data on disk</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cls_data&quot;</span><span class="p">,</span> <span class="s2">&quot;nside&quot;</span><span class="p">]</span>
        <span class="n">template_fit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">subtract_reference_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">subtract_template_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_noise_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_null&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">subtract_reference_signal</span><span class="p">:</span>
                <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_sub_null&quot;</span><span class="p">,</span> <span class="s2">&quot;cls_ref_null&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">template_fit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span> <span class="s2">&quot;cls_template&quot;</span><span class="p">,</span> <span class="s2">&quot;template_alpha&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subtract_template_noise</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">subtract_reference_signal</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cls_data_sub&quot;</span><span class="p">,</span> <span class="s2">&quot;cls_ref&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">template_alpha_sim</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha_sim</span> <span class="o">=</span> <span class="n">template_alpha_sim</span>
                <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;template_alpha_sim&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_template</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal data processing function to have scaled foreground template subtracted from data map.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">subtract_template_noise</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_template_noise&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cls_template_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_masked_template_noise</span><span class="p">()</span>

            <span class="n">cls_clean</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;cls_data_clean&quot;</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">template_specs</span><span class="p">):</span>
                <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_clean</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs_orig</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                    <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="n">template_alpha</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)]</span>

                    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t1</span>
                    <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t2</span>
                        <span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">+=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t3</span>
                            <span class="c1"># subtract average template noise spectrum to debias</span>
                            <span class="k">if</span> <span class="n">subtract_template_noise</span><span class="p">:</span>
                                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_template_noise</span><span class="p">[</span><span class="s2">&quot;temp1:temp2&quot;</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="n">d</span> <span class="o">-=</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">alphas</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_clean</span> <span class="o">=</span> <span class="n">cls_clean</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="o">=</span> <span class="n">template_alpha</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># change template subtraction coefficients for pre-loaded data</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">template_fit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">}</span>

            <span class="k">if</span> <span class="n">template_fit</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">template_alpha</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">):</span>
                    <span class="n">apply_template</span><span class="p">()</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">save_attrs</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">sim</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">save_sim</span><span class="p">:</span>
            <span class="c1"># rerun dependent steps if not saving sims to disk</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun_children</span><span class="p">(</span><span class="s2">&quot;sim_data&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;sim_data&quot;</span> <span class="k">if</span> <span class="n">sim</span> <span class="k">else</span> <span class="s2">&quot;data&quot;</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span>
                <span class="n">save_name</span><span class="p">,</span>
                <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
                <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
                <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_data&quot;</span><span class="p">,</span>
                <span class="n">data_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">extra_tag</span><span class="o">=</span><span class="s2">&quot;xcorr&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">template_alpha</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="n">apply_template</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># map spectra</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cls_null</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># set up template subtraction</span>
        <span class="n">cls_tmp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
            <span class="n">cls_tmp</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">template_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_files2</span><span class="p">))</span>

        <span class="c1"># set up reference subtraction</span>
        <span class="n">cls_ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">subtract_reference_signal</span><span class="p">:</span>
            <span class="n">cls_ref</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">cls_ref_null</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">reference_files_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reference_files</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ref1a&quot;</span><span class="p">,</span> <span class="s2">&quot;ref2a&quot;</span><span class="p">,</span> <span class="s2">&quot;ref1b&quot;</span><span class="p">,</span> <span class="s2">&quot;ref2b&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># set up noise residuals</span>
        <span class="n">rls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sim</span> <span class="ow">and</span> <span class="n">qb_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_residuals</span><span class="p">(</span><span class="n">qb_file</span><span class="p">)</span>

        <span class="c1"># convenience functions</span>
        <span class="k">def</span> <span class="nf">get_map_file</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># list of available file indices</span>
            <span class="n">fidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
            <span class="c1"># sim index for this component</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sidx</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sidx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fidx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Missing sim index </span><span class="si">{}</span><span class="s2"> in </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sidx</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">files</span><span class="p">[</span><span class="n">fidx</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sidx</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">get_map_alms</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">sim</span> <span class="ow">and</span> <span class="s2">&quot;noise&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span><span class="p">:</span>
                <span class="n">rls1</span> <span class="o">=</span> <span class="n">rls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sim</span><span class="p">:</span>
                <span class="c1"># data from disk</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;map_files&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># simulated data constructed from individual components</span>
                <span class="k">if</span> <span class="s2">&quot;signal&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;signal_files_sim&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;tensor_files_sim&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
                        <span class="n">m</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;noise&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;noise_files_sim&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
                    <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rls1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">mn</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">+=</span> <span class="n">mn</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                        <span class="n">mn_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">rls1</span><span class="p">:</span>
                                <span class="n">mn_alms</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">almxfl</span><span class="p">(</span><span class="n">mn_alms</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">rls1</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">mn</span>

                <span class="k">if</span> <span class="s2">&quot;foreground&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;foreground_files_sim&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>
                    <span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">mf</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">+=</span> <span class="n">mf</span>
                    <span class="k">del</span> <span class="n">mf</span>

                <span class="k">if</span> <span class="s2">&quot;template&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span><span class="p">:</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="n">template_alpha_sim</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="n">get_map_file</span><span class="p">(</span><span class="s2">&quot;template_files_sim&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                        <span class="n">mt</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">mt</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">+=</span> <span class="n">mt</span>
                        <span class="k">del</span> <span class="n">mt</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">sim</span> <span class="ow">and</span> <span class="s2">&quot;noise&quot;</span> <span class="ow">in</span> <span class="n">sim_type</span> <span class="ow">and</span> <span class="n">rls1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># add noise rescaled by residuals</span>
                <span class="n">m_alms</span> <span class="o">+=</span> <span class="n">mn_alms</span>

            <span class="k">return</span> <span class="n">m_alms</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A internal convenience function computes/loads alms from/to cache for each data map idx,</span>
<span class="sd">            or data map pair for null tests.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing Alms for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="n">get_map_alms</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="c1"># sum and diff spectra for null tests</span>
                <span class="c1"># XXX should not take average but sum here if we want to</span>
                <span class="c1"># compare power with sum...</span>
                <span class="n">m2_alms</span> <span class="o">=</span> <span class="n">get_map_alms</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">)</span>
                <span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span> <span class="o">+</span> <span class="n">m2_alms</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m_alms</span> <span class="o">-</span> <span class="n">m2_alms</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="k">del</span> <span class="n">m2_alms</span>

                <span class="k">if</span> <span class="n">subtract_reference_signal</span><span class="p">:</span>
                    <span class="c1"># cache raw data alms and reference alms together</span>
                    <span class="n">mp1ref1</span><span class="p">,</span> <span class="n">mp1ref2</span><span class="p">,</span> <span class="n">mp2ref1</span><span class="p">,</span> <span class="n">mp2ref2</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">mask</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">reference_files_split</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">m_alms_ref1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp1ref1</span> <span class="o">+</span> <span class="n">mp2ref1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">m_alms_ref2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp1ref2</span> <span class="o">+</span> <span class="n">mp2ref2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">mn_alms_ref1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp1ref1</span> <span class="o">-</span> <span class="n">mp2ref1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">mn_alms_ref2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp1ref2</span> <span class="o">-</span> <span class="n">mp2ref2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">m_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">m_alms_ref1</span><span class="p">,</span> <span class="n">m_alms_ref2</span><span class="p">)</span>
                    <span class="n">mn_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">mn_alms</span><span class="p">,</span> <span class="n">mn_alms_ref1</span><span class="p">,</span> <span class="n">mn_alms_ref2</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">template_fit</span><span class="p">:</span>
                <span class="c1"># cache raw data alms and template alms together</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="p">[</span><span class="n">m_alms</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">template_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Loading template from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tf</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                    <span class="n">mt_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">tf</span><span class="p">),</span> <span class="n">mask</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
                    <span class="p">)</span>
                    <span class="c1"># null out T template</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                        <span class="n">mt_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">0</span>
                    <span class="n">m_alms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mt_alms</span><span class="p">)</span>
                <span class="n">m_alms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m_alms</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_median</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">cls_dict</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_ens</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_null</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                        <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_ens_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="n">imap_alms</span><span class="p">,</span> <span class="n">inull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">jmap_alms</span><span class="p">,</span> <span class="n">jnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

            <span class="c1"># store cross spectra</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># raw map spectrum component</span>
                <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># average template alms</span>
                <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># compute maximally symmetric cross spectra</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># multiplies alpha_i</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmt</span><span class="p">)</span>  <span class="c1"># multiplies alpha_j</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">jmap_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>  <span class="c1"># multiplies alpha_i * alpha_j</span>

                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                    <span class="c1"># apply template to TE/TB but not TT</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">subtract_reference_signal</span> <span class="ow">and</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_ref</span> <span class="k">if</span> <span class="n">subtract_reference_signal</span> <span class="k">else</span> <span class="n">cls_tmp</span>
                    <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="c1"># do this again for the null maps</span>
                    <span class="n">cls_null1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># average template alms</span>
                    <span class="n">imt</span> <span class="o">=</span> <span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">jmt</span> <span class="o">=</span> <span class="p">(</span><span class="n">jnull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># compute maximally symmetric cross spectra</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imt</span><span class="p">,</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">jmt</span><span class="p">)</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">jnull_alms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">cls_ref_null</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                        <span class="n">cls_dict</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t2</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t3</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">cls1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">imap_alms</span><span class="p">,</span> <span class="n">jmap_alms</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_null1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">inull_alms</span><span class="p">,</span> <span class="n">jnull_alms</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_null</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="c1"># store and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span> <span class="o">=</span> <span class="n">cls_null</span>

        <span class="k">if</span> <span class="n">template_fit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_template</span> <span class="o">=</span> <span class="n">cls_tmp</span>
            <span class="n">apply_template</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">subtract_reference_signal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_ref</span> <span class="o">=</span> <span class="n">cls_ref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_ref_null</span> <span class="o">=</span> <span class="n">cls_ref_null</span>

            <span class="n">cls_data_sub</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="n">cls_data_sub_null</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_data_sub</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_ref</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">+=</span> <span class="o">-</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span>

                <span class="c1"># do null specs</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_data_sub_null</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_ref_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">d</span> <span class="o">+=</span> <span class="o">-</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub</span> <span class="o">=</span> <span class="n">cls_data_sub</span>
            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub_null</span> <span class="o">=</span> <span class="n">cls_data_sub_null</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sim</span> <span class="ow">or</span> <span class="n">save_sim</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="s2">&quot;xcorr&quot;</span><span class="p">,</span> <span class="n">data_opts</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_sims"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_sims">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qb_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average signal and noise spectra for a given ensemble of sim</span>
<span class="sd">        maps.  The same procedure that is used for computing data cross spectra</span>
<span class="sd">        is used for each realization in the sim ensemble, and only the average</span>
<span class="sd">        spectra for all realizations are stored.</span>

<span class="sd">        See ``get_masked_data`` for more details on how cross spectra are</span>
<span class="sd">        computed.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, use the signal ensemble corresponding to</span>
<span class="sd">            `signal_transfer_type`.  Otherwise, uses the standard `signal_type`</span>
<span class="sd">            ensemble.</span>
<span class="sd">        do_noise : bool</span>
<span class="sd">            If True, include noise spectra in the output, as long as</span>
<span class="sd">            `noise_type` is supplied.  Otherwise, only the signal component is</span>
<span class="sd">            computed.</span>
<span class="sd">        qb_file : string</span>
<span class="sd">            Pointer to a bandpowers.npz file in the output directory, used</span>
<span class="sd">            to correct the ensemble mean noise spectrum by the appropriate</span>
<span class="sd">            residual terms.  See ``get_noise_residuals`` for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;sims&#39; checkpoint, and loads or saves</span>
<span class="sd">        a data dictionary with the following keys:</span>

<span class="sd">            cls_signal, cls_signal_null:</span>
<span class="sd">                Mean signal spectra</span>
<span class="sd">            cls_noise, cls_noise_null:</span>
<span class="sd">                Mean noise spectra</span>
<span class="sd">            cls_sim, cls_sim_null:</span>
<span class="sd">                Mean signal+noise spectra</span>
<span class="sd">            cls_med, cls_med_null:</span>
<span class="sd">                Median signal+noise spectra</span>
<span class="sd">            cls_res, cls_res_null:</span>
<span class="sd">                NxN, SxN and NxS spectra for computing noise residuals</span>

<span class="sd">        For null tests, difference spectra of the two null halves are stored</span>
<span class="sd">        in the corresponding `*_null` keys, and summed spectra are stored</span>
<span class="sd">        in the normal keys.  Note that these differ from standard non-null</span>
<span class="sd">        spectra by a factor of 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">num_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span>
        <span class="n">null_run</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">signal_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_files</span>
            <span class="n">signal_files2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">num_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_signal_transfer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files</span>
            <span class="n">signal_files2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">num_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_signal</span>

        <span class="n">noise_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files</span>
        <span class="n">noise_files2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_files2</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">num_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_noise</span>

        <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="n">do_noise</span> <span class="o">=</span> <span class="n">noise_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;cls_signal&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_noise&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_sim&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_med&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cls_res&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">save_attrs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="s2">&quot;cls_signal_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_noise_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_sim_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_med_null&quot;</span><span class="p">,</span>
                <span class="s2">&quot;cls_res_null&quot;</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;sims_xcorr_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_type</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;sims_transfer&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;sims_xcorr_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_type</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;sims&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="n">cp</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_signal&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ret</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_noise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_noise_null&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># don&#39;t rerun sims a second time if they&#39;ve already been run once</span>
            <span class="c1"># with the same signal type</span>
            <span class="k">if</span> <span class="n">transfer</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_type</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="s2">&quot;sims&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># process signal, noise, and S+N</span>
        <span class="n">cls_sig</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cls_null_sig</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">cls_noise</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">cls_null_noise</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">cls_tot</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cls_null_tot</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">cls_med</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cls_null_med</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1">### Noise iteration from res fit fields</span>
        <span class="n">cls_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">cls_null_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">null_run</span> <span class="ow">and</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;nxn0&quot;</span><span class="p">,</span> <span class="s2">&quot;nxn1&quot;</span><span class="p">,</span> <span class="s2">&quot;sxn0&quot;</span><span class="p">,</span> <span class="s2">&quot;sxn1&quot;</span><span class="p">,</span> <span class="s2">&quot;nxs0&quot;</span><span class="p">,</span> <span class="s2">&quot;nxs1&quot;</span><span class="p">]:</span>
                <span class="n">cls_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                    <span class="n">cls_null_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">num_noise</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nsim_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">num_signal</span><span class="p">,</span> <span class="n">num_noise</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsim_min</span> <span class="o">=</span> <span class="n">num_signal</span>
        <span class="n">nsim_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">num_signal</span><span class="p">,</span> <span class="n">num_noise</span><span class="p">])</span>
        <span class="n">cls_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">[</span><span class="n">nsim_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">cls_all_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cls_all</span><span class="p">)</span>

        <span class="n">rls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="n">qb_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_residuals</span><span class="p">(</span><span class="n">qb_file</span><span class="p">)</span>

        <span class="c1"># convenience functions</span>
        <span class="k">def</span> <span class="nf">get_map_alms</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">rls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">rls</span><span class="p">:</span>
                        <span class="n">m_alms</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">almxfl</span><span class="p">(</span><span class="n">m_alms</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">rls</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">m_alms</span>

        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">files2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute alms of masked input map</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="n">filename</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">idx2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">),</span> <span class="s2">&quot;all&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing Alms for sim </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">idx2</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;all&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">rls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rls</span> <span class="o">=</span> <span class="n">rls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">map_tags</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">m_alms</span> <span class="o">=</span> <span class="n">get_map_alms</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">rls</span><span class="o">=</span><span class="n">rls</span><span class="p">)</span>
            <span class="n">mn_alms</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                <span class="c1"># second null half</span>
                <span class="n">filename2</span> <span class="o">=</span> <span class="n">files2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filename2</span> <span class="o">=</span> <span class="n">filename2</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>

                <span class="n">m2_alms</span> <span class="o">=</span> <span class="n">get_map_alms</span><span class="p">(</span><span class="n">filename2</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">rls</span><span class="o">=</span><span class="n">rls</span><span class="p">)</span>
                <span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span> <span class="o">+</span> <span class="n">m2_alms</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m_alms</span> <span class="o">-</span> <span class="n">m2_alms</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_alms</span><span class="p">,</span> <span class="n">mn_alms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">sig_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">noise_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsim_max</span><span class="p">):</span>
            <span class="n">sig_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">noise_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2"> for signal</span><span class="si">{}</span><span class="s2"> sim </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">xname</span><span class="p">,</span> <span class="s2">&quot;+noise&quot;</span> <span class="k">if</span> <span class="n">do_noise</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">isim</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">num_signal</span><span class="p">:</span>
                    <span class="n">simap_alms</span><span class="p">,</span> <span class="n">sinull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">signal_files</span><span class="p">,</span> <span class="n">signal_files2</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">sig_cache</span>
                    <span class="p">)</span>
                    <span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">signal_files</span><span class="p">,</span> <span class="n">signal_files2</span><span class="p">,</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">isim</span><span class="p">,</span> <span class="n">sig_cache</span>
                    <span class="p">)</span>

                    <span class="n">cls1_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">simap_alms</span><span class="p">,</span> <span class="n">sjmap_alms</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">cls_null1_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">sinull_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                        <span class="n">cls1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cls1_sig</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_null1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cls_null1_sig</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">num_noise</span><span class="p">:</span>
                    <span class="n">cls1_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">cls_null1_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

                    <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">ninull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">noise_files</span><span class="p">,</span>
                        <span class="n">noise_files2</span><span class="p">,</span>
                        <span class="n">idx</span><span class="p">,</span>
                        <span class="n">isim</span><span class="p">,</span>
                        <span class="n">noise_cache</span><span class="p">,</span>
                        <span class="n">rls</span><span class="o">=</span><span class="n">rls</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">njnull_alms</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span>
                        <span class="n">noise_files</span><span class="p">,</span>
                        <span class="n">noise_files2</span><span class="p">,</span>
                        <span class="n">jdx</span><span class="p">,</span>
                        <span class="n">isim</span><span class="p">,</span>
                        <span class="n">noise_cache</span><span class="p">,</span>
                        <span class="n">rls</span><span class="o">=</span><span class="n">rls</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># need non-symmetric since will potentially modify these</span>
                    <span class="c1"># with different residuals for T, E, B</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cnx</span><span class="p">,</span> <span class="n">cny</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="p">(</span><span class="s2">&quot;nxn&quot;</span><span class="p">,</span> <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">njnull_alms</span><span class="p">),</span>
                        <span class="p">(</span><span class="s2">&quot;sxn&quot;</span><span class="p">,</span> <span class="n">simap_alms</span><span class="p">,</span> <span class="n">njmap_alms</span><span class="p">,</span> <span class="n">sinull_alms</span><span class="p">,</span> <span class="n">njnull_alms</span><span class="p">),</span>
                        <span class="p">(</span><span class="s2">&quot;nxs&quot;</span><span class="p">,</span> <span class="n">nimap_alms</span><span class="p">,</span> <span class="n">sjmap_alms</span><span class="p">,</span> <span class="n">ninull_alms</span><span class="p">,</span> <span class="n">sjnull_alms</span><span class="p">),</span>
                    <span class="p">]:</span>
                        <span class="n">k0</span><span class="p">,</span> <span class="n">k1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                        <span class="n">cls1_res</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">cls1_res</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_null1_res</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">cnx</span><span class="p">,</span> <span class="n">cny</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="n">cls_null1_res</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">cny</span><span class="p">,</span> <span class="n">cnx</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># construct noise model</span>
                    <span class="n">cls1_noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">cls1_res</span><span class="p">[</span><span class="s2">&quot;nxn0&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">cls1_res</span><span class="p">[</span><span class="s2">&quot;nxn1&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">cls_null1_noise</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">cls_null1_res</span><span class="p">[</span><span class="s2">&quot;nxn0&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">cls_null1_res</span><span class="p">[</span><span class="s2">&quot;nxn1&quot;</span><span class="p">]</span>
                        <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

                    <span class="c1"># construct total model</span>
                    <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls1_res</span><span class="p">:</span>
                            <span class="n">cls1t</span> <span class="o">+=</span> <span class="n">cls1_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                            <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                                <span class="n">cls_null1t</span> <span class="o">+=</span> <span class="n">cls_null1_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="n">quants</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">num_signal</span><span class="p">:</span>
                    <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_sig</span><span class="p">,</span> <span class="n">cls1_sig</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_null_sig</span><span class="p">,</span> <span class="n">cls_null1_sig</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">do_noise</span> <span class="ow">and</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">num_noise</span><span class="p">:</span>
                    <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cls1_noise</span><span class="p">]]</span>
                    <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_res</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cls1_res</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls_res</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_null_noise</span><span class="p">,</span> <span class="n">cls_null1_noise</span><span class="p">]]</span>
                        <span class="n">quants</span> <span class="o">+=</span> <span class="p">[</span>
                            <span class="p">[</span><span class="n">cls_null_res</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cls_null1_res</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls_null_res</span>
                        <span class="p">]</span>
                <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                    <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_tot</span><span class="p">,</span> <span class="n">cls1t</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                        <span class="n">quants</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">cls_null_tot</span><span class="p">,</span> <span class="n">cls_null1t</span><span class="p">]]</span>

                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                    <span class="c1"># running average</span>
                    <span class="k">for</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">quants</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">q0</span><span class="p">:</span>
                            <span class="n">q0</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">q0</span><span class="p">[</span><span class="n">spec</span><span class="p">]:</span>
                            <span class="n">q0</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">q0</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">d</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">isim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># in-place</span>

                    <span class="c1"># matrix form for efficient median</span>
                    <span class="k">if</span> <span class="n">isim</span> <span class="o">&lt;</span> <span class="n">nsim_min</span><span class="p">:</span>
                        <span class="n">cls_all</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_tot</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
                            <span class="n">cls_all_null</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null_tot</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

        <span class="n">cls_med_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cls_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
            <span class="n">cls_med</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                <span class="n">cls_med</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_med_arr</span><span class="p">[</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">null_run</span><span class="p">:</span>
            <span class="n">cls_null_med_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">cls_all_null</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                <span class="n">cls_null_med</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xind</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                    <span class="n">cls_null_med</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_null_med_arr</span><span class="p">[</span><span class="n">xind</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span> <span class="o">=</span> <span class="n">cls_sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal_null</span> <span class="o">=</span> <span class="n">cls_null_sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="o">=</span> <span class="n">cls_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="o">=</span> <span class="n">cls_null_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim</span> <span class="o">=</span> <span class="n">cls_tot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span> <span class="o">=</span> <span class="n">cls_null_tot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_med</span> <span class="o">=</span> <span class="n">cls_med</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_med_null</span> <span class="o">=</span> <span class="n">cls_null_med</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_res</span> <span class="o">=</span> <span class="n">cls_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls_res_null</span> <span class="o">=</span> <span class="n">cls_null_res</span>

        <span class="c1"># save and return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_masked_template_noise"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_masked_template_noise">[docs]</a>    <span class="k">def</span> <span class="nf">get_masked_template_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all combinations of template noise cross spectra from the ensemble</span>
<span class="sd">        of template noise sims.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls_template_noise : OrderedDict</span>
<span class="sd">            Dictionary of template noise spectra averaged over all sims, containing</span>
<span class="sd">            the following keys: [&quot;temp1:temp1&quot;, &quot;temp2:temp2&quot;, &quot;temp1:temp2&quot;].  Each entry</span>
<span class="sd">            has the same shape structure as the ``cls_data`` attribute.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;template_noise&#39; checkpoint, and loads or</span>
<span class="sd">        saves a data dictionary containing the ``cls_template_noise`` attribute</span>
<span class="sd">        that is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_noise_type</span>
        <span class="n">mask_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_files</span>
        <span class="n">map_files</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">template_noise_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_noise_files2</span><span class="p">]</span>
        <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cls_template_noise&quot;</span><span class="p">]</span>
        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;template_noise_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">template_type</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;template_noise&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_template_noise&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_template_noise&quot;</span><span class="p">]</span>

        <span class="n">cls_template_noise</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;temp1:temp1&quot;</span><span class="p">,</span> <span class="s2">&quot;temp2:temp2&quot;</span><span class="p">,</span> <span class="s2">&quot;temp1:temp2&quot;</span><span class="p">]:</span>
            <span class="n">cls_template_noise</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># convenience functions</span>
        <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute alms of masked temp1 and temp2 template noise sims</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Computing Alms for sim </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">isim</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_maps</span>
                <span class="p">),</span>
                <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">mask_files</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="n">m_alms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">isim</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">map_files</span><span class="p">]:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                <span class="n">m_alms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map2alm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">))</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_alms</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_template_noise</span><span class="p">):</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Computing spectra </span><span class="si">{}</span><span class="s2"> for template noise sim </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">xname</span><span class="p">,</span> <span class="n">isim</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">temp1i</span><span class="p">,</span> <span class="n">temp2i</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">isim</span><span class="p">)</span>
                <span class="n">temp1j</span><span class="p">,</span> <span class="n">temp2j</span> <span class="o">=</span> <span class="n">process_index</span><span class="p">(</span><span class="n">jdx</span><span class="p">,</span> <span class="n">isim</span><span class="p">)</span>

                <span class="n">cls1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">cls1</span><span class="p">[</span><span class="s2">&quot;temp1:temp1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">temp1i</span><span class="p">,</span> <span class="n">temp1j</span><span class="p">)</span>
                <span class="n">cls1</span><span class="p">[</span><span class="s2">&quot;temp2:temp2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">temp2i</span><span class="p">,</span> <span class="n">temp2j</span><span class="p">)</span>
                <span class="n">cls1</span><span class="p">[</span><span class="s2">&quot;temp1:temp2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">temp1i</span><span class="p">,</span> <span class="n">temp2j</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alm2cl</span><span class="p">(</span><span class="n">temp2i</span><span class="p">,</span> <span class="n">temp1j</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q1</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">cls_template_noise</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cls1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">):</span>
                        <span class="n">dd</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dd</span><span class="p">:</span>
                            <span class="n">dd</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">d</span><span class="p">[:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">isim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># in-place</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cls_template_noise</span> <span class="o">=</span> <span class="n">cls_template_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls_template_noise</span></div>

<div class="viewcode-block" id="XFaster.get_kernels"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_kernels">[docs]</a>    <span class="k">def</span> <span class="nf">get_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute kernels using the mask cross-spectra.  This follows</span>
<span class="sd">        the polspice azimuthal approximation for the kernel computation.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        window_lmax : int</span>
<span class="sd">            The window within which the kernel is computed about</span>
<span class="sd">            each ell bin.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;kernels&#39; checkpoint and loads or saves</span>
<span class="sd">        the following data keys to disk:</span>

<span class="sd">            kern:</span>
<span class="sd">                temperature kernel</span>
<span class="sd">            pkern, mkern:</span>
<span class="sd">                + and - polarization kernels</span>
<span class="sd">            xkern:</span>
<span class="sd">                temperature/polarization cross term kernel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">window_lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;kernels&quot;</span>
        <span class="n">save_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kern&quot;</span><span class="p">,</span> <span class="s2">&quot;pkern&quot;</span><span class="p">,</span> <span class="s2">&quot;mkern&quot;</span><span class="p">,</span> <span class="s2">&quot;xkern&quot;</span><span class="p">,</span> <span class="s2">&quot;window_lmax&quot;</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;kernels&quot;</span><span class="p">,</span>
            <span class="n">fields</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kern_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;kern&quot;</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;window_lmax&quot;</span><span class="p">:</span> <span class="n">window_lmax</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">kern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="n">pkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">mkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">xkern</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pkern</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mkern</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xkern</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
        <span class="n">wls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wls</span>

        <span class="n">all_ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
            <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing kernels for ell </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lmax</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># populate upper triangle</span>
            <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">l2</span><span class="p">]:</span>
                <span class="n">j0</span><span class="p">,</span> <span class="n">j0_lmin</span><span class="p">,</span> <span class="n">j0_lmax</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">wigner3j</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">j2</span><span class="p">,</span> <span class="n">j2_lmin</span><span class="p">,</span> <span class="n">j2_lmax</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">wigner3j</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># only go up to window lmax</span>
                <span class="n">j0_lmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">j0_lmax</span><span class="p">,</span> <span class="n">window_lmax</span><span class="p">)</span>

                <span class="c1"># computed as in https://arxiv.org/abs/1909.09375</span>
                <span class="c1"># equations 128 - 136</span>
                <span class="n">l3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">j0_lmin</span><span class="p">,</span> <span class="n">j0_lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dl3</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">l3</span> <span class="o">+</span> <span class="mf">1.0</span>
                <span class="n">vk</span> <span class="o">=</span> <span class="n">j0</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dl3</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">l3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">j2</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dl3</span>
                    <span class="n">vp</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">vm</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">vx</span> <span class="o">=</span> <span class="n">j2</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">*</span> <span class="n">j0</span><span class="p">[</span><span class="n">l3</span><span class="p">]</span> <span class="o">*</span> <span class="n">dl3</span>
                <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                    <span class="n">wls1</span> <span class="o">=</span> <span class="n">wls</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">l3</span><span class="p">]</span>
                    <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vk</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                        <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vp</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vm</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vx</span> <span class="o">*</span> <span class="n">wls1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># apply symmetry relation</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_ells</span><span class="p">[</span><span class="mi">2</span> <span class="p">:</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dll</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ll</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">sll</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="c1"># populate lower triangle (wigners are symmetric in l and ll)</span>
                <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                    <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                    <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">sll</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="n">sll</span><span class="p">]</span>
                <span class="c1"># apply ell scaling along the axis that we bin over</span>
                <span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                <span class="k">if</span> <span class="n">pol</span><span class="p">:</span>
                    <span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                    <span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>
                    <span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">l</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="n">dll</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kern</span> <span class="o">=</span> <span class="n">kern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span> <span class="o">=</span> <span class="n">pkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span> <span class="o">=</span> <span class="n">mkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xkern</span> <span class="o">=</span> <span class="n">xkern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_lmax</span> <span class="o">=</span> <span class="n">window_lmax</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="n">save_attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_signal_shape"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_signal_shape">[docs]</a>    <span class="k">def</span> <span class="nf">get_signal_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">flat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filename_fg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_ref</span><span class="o">=</span><span class="mf">359.7</span><span class="p">,</span>
        <span class="n">beta_ref</span><span class="o">=</span><span class="mf">1.54</span><span class="p">,</span>
        <span class="n">signal_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a shape spectrum for input to the Fisher iteration algorithm.</span>

<span class="sd">        If the spectrum is used as input to ``get_transfer``, it must match</span>
<span class="sd">        the spectrum used to generate the simulations, in order to compute</span>
<span class="sd">        the correct transfer function.</span>

<span class="sd">        Alternatively, the spectrum can be computed using CAMB for arbitrary</span>
<span class="sd">        values of ``r``, typically used to compute the ``r`` likelihood once</span>
<span class="sd">        the bandpowers have been computed.</span>

<span class="sd">        Finally, the spectrum can be flat in ell^2 Cl.  This is typically</span>
<span class="sd">        used as the input shape for computing bandpowers for a null test.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        filename : string</span>
<span class="sd">            Filename for a signal spectrum on disk.  If None, and ``r`` is None</span>
<span class="sd">            and ``flat`` is False, this will search for a spectrum stored in</span>
<span class="sd">            ``signal_&lt;signal_type&gt;/spec_signal_&lt;signal_type&gt;.dat``.  Otherwise,</span>
<span class="sd">            if the filename is a relative path and not found, the config</span>
<span class="sd">            directory is searched.</span>
<span class="sd">        r : float</span>
<span class="sd">            If supplied and ``flat`` is False, a spectrum is computed using</span>
<span class="sd">            CAMB for the given ``r`` value.  Overrides ``filename``.</span>
<span class="sd">        component : &#39;scalar&#39;, &#39;tensor&#39;, &#39;cmb&#39;, &#39;fg&#39;</span>
<span class="sd">            If &#39;scalar&#39;, and ``r`` is not None, return just the r=0 scalar terms</span>
<span class="sd">            in the signal model.  If &#39;tensor&#39;, return just the tensor component</span>
<span class="sd">            scaled by the input ``r`` value. If &#39;cmb&#39; or &#39;fg&#39;, return just those</span>
<span class="sd">            signal terms.</span>
<span class="sd">        flat : float</span>
<span class="sd">            If given, a spectrum that is flat in ell^2 Cl is returned, with</span>
<span class="sd">            amplitude given by the supplied value. Overrides all other options.</span>
<span class="sd">        filename_fg : string</span>
<span class="sd">            Filename for a foreground spectrum on disk.  If the filename is a</span>
<span class="sd">            relative path and not found, the config directory is searched.  If</span>
<span class="sd">            not supplied, a power law dust model spectrum is assumed.</span>
<span class="sd">        freq_ref : float</span>
<span class="sd">            In GHz, reference frequency for dust model. Dust bandpowers output</span>
<span class="sd">            will be at this reference frequency.</span>
<span class="sd">        beta_ref : float</span>
<span class="sd">            The spectral index of the dust model. This is a fixed value, with</span>
<span class="sd">            an additive deviation from this value fit for in foreground fitting</span>
<span class="sd">            mode.</span>
<span class="sd">        signal_mask: str array</span>
<span class="sd">            Include only these spectra, others set to zero.</span>
<span class="sd">            Options: TT, EE, BB, TE, EB, TB</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, this is a transfer function run. If ``filename`` is None</span>
<span class="sd">            and ``r`` is None and ``flat`` is False, will search for a signal</span>
<span class="sd">            spectrum stored in</span>
<span class="sd">            ``signal_&lt;signal_transfer_type&gt;/spec_signal_&lt;signal_transfer_type&gt;.dat``.</span>
<span class="sd">        save : bool</span>
<span class="sd">            If True, save signal shape dict to disk.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : OrderedDict</span>
<span class="sd">            Dictionary keyed by spectrum (cmb_tt, cmb_ee, ... , fg_tt, ...),</span>
<span class="sd">            each entry containing a vector of length 2 * lmax + 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lmax_kern</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="ow">or</span> <span class="n">transfer</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="n">comps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;fg&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">,</span> <span class="s2">&quot;tensor&quot;</span><span class="p">]:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;eb&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>
        <span class="n">tbeb</span> <span class="o">=</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span> <span class="ow">and</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">comps</span><span class="p">),</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;shape_transfer&quot;</span> <span class="k">if</span> <span class="n">transfer</span> <span class="k">else</span> <span class="s2">&quot;shape&quot;</span>

            <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">signal_mask</span><span class="o">=</span><span class="n">signal_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">filename_fg</span><span class="o">=</span><span class="n">filename_fg</span><span class="p">,</span> <span class="n">freq_ref</span><span class="o">=</span><span class="n">freq_ref</span><span class="p">,</span> <span class="n">beta_ref</span><span class="o">=</span><span class="n">beta_ref</span>
                <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">save_name</span><span class="p">,</span> <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">in</span> <span class="n">comps</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;r_model&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">freq_ref</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;freq_ref&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;beta_ref&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;fg_scales&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ellfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">cls_shape</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flat</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">flat</span> <span class="o">=</span> <span class="mf">2e-5</span>
                <span class="c1"># flat spectrum for null tests</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_&quot;</span> <span class="o">+</span> <span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ell</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># cache model components</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;r_model&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># scalar CAMB spectrum</span>
                    <span class="n">scal</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_camb_cl</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">)</span>
                    <span class="c1"># tensor CAMB spectrum for r=1, scales linearly with r</span>
                    <span class="n">tens</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_camb_cl</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">,</span> <span class="n">nt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spec</span><span class="o">=</span><span class="s2">&quot;tensor&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scalar&quot;</span><span class="p">:</span> <span class="n">scal</span><span class="p">,</span> <span class="s2">&quot;tensor&quot;</span><span class="p">:</span> <span class="n">tens</span><span class="p">}</span>
                    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                        <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;r_model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span>
                <span class="c1"># CAMB spectrum for given r value</span>
                <span class="n">component</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;scalar&quot;</span><span class="p">:</span>
                    <span class="n">cls_camb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;tensor&quot;</span><span class="p">:</span>
                    <span class="n">cls_camb</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;tensor&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cls_camb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_model</span><span class="p">[</span><span class="s2">&quot;tensor&quot;</span><span class="p">]</span>
                <span class="n">cls_shape</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;cmb_&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span> <span class="bp">cls</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">cls_camb</span><span class="p">)})</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># signal sim model or custom filename</span>
                <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">signal_root</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">signal_transfer_root</span> <span class="k">if</span> <span class="n">transfer</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_root</span>
                    <span class="p">)</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;spec_</span><span class="si">{}</span><span class="s2">.dat&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">signal_root</span><span class="p">))</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">signal_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Missing model file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

                <span class="n">cls_cmb</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">load_camb_cl</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="n">cls_shape</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;cmb_&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span> <span class="bp">cls</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">cls_cmb</span><span class="p">)})</span>

            <span class="c1"># EB and TB flat l^2 * C_l</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tbeb</span> <span class="ow">and</span> <span class="p">(</span><span class="n">flat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">flat</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">][</span><span class="mi">100</span><span class="p">])</span> <span class="o">*</span> <span class="n">ellfac</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-4</span>
                    <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">tbeb_flat</span>
                    <span class="n">tbeb_flat</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">tbeb</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;cmb_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="c1"># dust signal sim model or custom filename</span>
            <span class="c1"># XXX optionally load freq_ref and beta_ref from file</span>
            <span class="k">if</span> <span class="n">filename_fg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># From Planck LIV EE dust</span>
                <span class="n">cls_dust</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">dust_model</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">lfac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">[:</span><span class="mi">4</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_&quot;</span> <span class="o">+</span> <span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_dust</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Added simple foregrounds to cls shape </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">)),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_fg</span><span class="p">):</span>
                    <span class="n">filename_fg</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_root</span><span class="p">,</span> <span class="n">filename_fg</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename_fg</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                        <span class="s2">&quot;Missing foreground model file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename_fg</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">cls_fg</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">load_camb_cl</span><span class="p">(</span><span class="n">filename_fg</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="n">lmax_kern</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">cls_shape</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fg_&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span> <span class="bp">cls</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">cls_fg</span><span class="p">)})</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tbeb</span> <span class="ow">and</span> <span class="s2">&quot;fg_eb&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="p">:</span>
                    <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_ee&quot;</span><span class="p">][</span><span class="mi">100</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e-4</span>
                    <span class="n">tbeb_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_ee&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">tbeb_flat</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">tbeb_flat</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="s2">&quot;fg_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># frequency scaling for cross spectra</span>
            <span class="n">fg_scales</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">m0</span><span class="p">]</span>
                <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">[</span><span class="n">m1</span><span class="p">]</span>
                <span class="n">fg_scales</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">scale_dust</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">freq_ref</span><span class="p">,</span> <span class="n">beta_ref</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span> <span class="o">=</span> <span class="n">fg_scales</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq_ref</span> <span class="o">=</span> <span class="n">freq_ref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span> <span class="o">=</span> <span class="n">beta_ref</span>
            <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;fg_scales&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span>

        <span class="c1"># divide out l^2/2pi</span>
        <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">cl</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">/=</span> <span class="n">ellfac</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">cl</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">signal_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Masking </span><span class="si">{}</span><span class="s2"> spectra&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signal_mask</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">csk</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="p">:</span>
                <span class="n">masked</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">smk</span> <span class="ow">in</span> <span class="n">signal_mask</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">smk</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">csk</span><span class="p">:</span>
                        <span class="n">masked</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
                    <span class="n">cls_shape</span><span class="p">[</span><span class="n">csk</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0e-12</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span> <span class="o">=</span> <span class="n">cls_shape</span>
            <span class="n">opts</span><span class="p">[</span><span class="s2">&quot;cls_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls_shape</span></div>

<div class="viewcode-block" id="XFaster.get_beams"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_beams">[docs]</a>    <span class="k">def</span> <span class="nf">get_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pixwin</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return beam window functions for all input map tags.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        pixwin : bool</span>
<span class="sd">            If True, the pixel window function for the map ``nside`` is</span>
<span class="sd">            applied to the Gaussian beams.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        beam_windows : dict</span>
<span class="sd">            A dictionary of beam window function arrays</span>
<span class="sd">            (3 x lmax+1 if pol, 1 x lmax+1 if not) for each map tag</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;beams&#39; checkpoint and loads or saves</span>
<span class="sd">        a dictionary containing just the ``beam_windows`` key to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>

        <span class="n">lsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="mi">6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">beam_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">*</span> <span class="n">nspec</span><span class="p">,</span> <span class="n">lsize</span><span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;beams&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;beams&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">],</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">beam_shape</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">]</span>

        <span class="n">beam_windows</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">pwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lsize</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">pixwin</span><span class="p">:</span>
            <span class="n">pwl</span> <span class="o">*=</span> <span class="mf">0.0</span>
            <span class="n">pix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pixwin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="n">pixT</span> <span class="o">=</span> <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pixP</span> <span class="o">=</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixT</span><span class="p">),</span> <span class="n">lsize</span><span class="p">)</span>
                <span class="n">pwl</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixP</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">pwl</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pixT</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span> <span class="o">*</span> <span class="n">pixP</span><span class="p">[:</span><span class="n">end</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pixT</span> <span class="o">=</span> <span class="n">pix</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixT</span><span class="p">),</span> <span class="n">lsize</span><span class="p">)</span>
            <span class="n">pwl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixT</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">otag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">:</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beam_product</span><span class="p">[</span><span class="n">otag</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">:</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">[</span><span class="n">otag</span><span class="p">],</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No beam in config for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>

            <span class="n">blpw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bl</span> <span class="o">*</span> <span class="n">pwl</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_windows</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">blpw</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span> <span class="o">=</span> <span class="n">beam_windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_windows&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span></div>

<div class="viewcode-block" id="XFaster.get_beam_errors"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_beam_errors">[docs]</a>    <span class="k">def</span> <span class="nf">get_beam_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get error envelope to multiply beam by (so, to get beam + 2 sigma error,</span>
<span class="sd">        do beam * (1 + 2 * beam_error))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nspec</span> <span class="o">=</span> <span class="mi">6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">beam_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">*</span> <span class="n">nspec</span><span class="p">,</span> <span class="n">lsize</span><span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;beam_errors&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="s2">&quot;beam_errors&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;beam_errors&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_rerun</span><span class="p">[</span><span class="n">cp</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">],</span> <span class="n">to_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">beam_shape</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">]</span>

        <span class="n">beam_errors</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">beam_errors</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">otag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">:</span>
                <span class="n">be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_error_product</span><span class="p">[</span><span class="n">otag</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">otag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">:</span>
                <span class="c1"># convert error on the FWHM to an envelope error on the beam window</span>
                <span class="n">fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">[</span><span class="n">otag</span><span class="p">]</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>
                <span class="n">blp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span>
                    <span class="n">fwhm</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">[</span><span class="n">otag</span><span class="p">]),</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
                <span class="p">)</span>
                <span class="n">blm</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">gauss_beam</span><span class="p">(</span>
                    <span class="n">fwhm</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm_err</span><span class="p">[</span><span class="n">otag</span><span class="p">]),</span> <span class="n">lsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                    <span class="n">bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">bl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]]</span>
                    <span class="p">)</span>
                    <span class="n">blp</span> <span class="o">=</span> <span class="n">blp</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
                    <span class="n">blm</span> <span class="o">=</span> <span class="n">blm</span><span class="o">.</span><span class="n">T</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
                <span class="n">be</span> <span class="o">=</span> <span class="p">(</span><span class="n">blp</span> <span class="o">-</span> <span class="n">blm</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">bl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No beam in config for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">otag</span><span class="p">))</span>

            <span class="n">be</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">be</span><span class="p">)[:,</span> <span class="p">:</span><span class="n">lsize</span><span class="p">]</span>
            <span class="n">beam_errors</span><span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">beam_errors</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">be</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># save and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span> <span class="o">=</span> <span class="n">beam_errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;beam_errors&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_errors</span></div>

<div class="viewcode-block" id="XFaster.get_bin_def"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_bin_def">[docs]</a>    <span class="k">def</span> <span class="nf">get_bin_def</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">lmax</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">pol</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pol_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tbeb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bin_width</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">weighted_bins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">residual_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">res_specs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bin_width_res</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">foreground_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">beta_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bin_width_fg</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">lmin_fg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lmax_fg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the bin definition array that defines the bins for each output</span>
<span class="sd">        spectrum.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        lmin : int</span>
<span class="sd">            Minimum ell for binned spectra</span>
<span class="sd">        lmax : int</span>
<span class="sd">            The maximum multipole for which spectra are computed</span>
<span class="sd">        pol : bool</span>
<span class="sd">            If True, polarized spectra are computed from the input maps</span>
<span class="sd">        pol_mask : bool</span>
<span class="sd">            If True, two independent masks are applied to every map:</span>
<span class="sd">            one for T maps and one for Q/U maps.</span>
<span class="sd">        tbeb : bool</span>
<span class="sd">            If True, EB and TB bins are constructed so that these spectra are</span>
<span class="sd">            computed by the estimator.  Otherwise, these spectra are fixed at</span>
<span class="sd">            zero.</span>
<span class="sd">        bin_width : int or list of ints</span>
<span class="sd">            Width of each spectrum bin.  If a scalar, the same width is applied</span>
<span class="sd">            to all cross spectra.  Otherwise, must be a list of up to six</span>
<span class="sd">            elements, listing bin widths for the spectra in the order (TT, EE,</span>
<span class="sd">            BB, TE, EB, TB).</span>
<span class="sd">        weighted_bins : bool</span>
<span class="sd">            If True, use an lfac-weighted binning operator to construct Cbls.</span>
<span class="sd">            By default, a flat binning operator is used.</span>
<span class="sd">        residual_fit : bool</span>
<span class="sd">            If True, fit for (compute bandpower amplitudes for) several wide</span>
<span class="sd">            bins of excess noise.</span>
<span class="sd">        res_specs : list of strings</span>
<span class="sd">            List of spectra which are to be included in the residual fit.  Can</span>
<span class="sd">            be individual spectra (&#39;tt&#39;, &#39;ee&#39;, &#39;bb&#39;), or &#39;eebb&#39; to fit for EE</span>
<span class="sd">            and BB residuals simultaneously.  If not supplied, this defaults to</span>
<span class="sd">            [&#39;eebb&#39;] for polarized maps, and [&#39;tt&#39;] for unpolarized maps.</span>
<span class="sd">        bin_width_res : int or list of ints</span>
<span class="sd">            Width of each residual spectrum bin.  If a scalar, the same width</span>
<span class="sd">            is applied to all spectra for all cross spectra.  Otherwise, must</span>
<span class="sd">            be a list of up to nspec * nmaps elements, listing bin widths for</span>
<span class="sd">            each of the spectra in ``res_specs`` in order, then ordered by map.</span>
<span class="sd">        foreground_fit : bool</span>
<span class="sd">            If True, construct bin definitions for foreground components as</span>
<span class="sd">            well.</span>
<span class="sd">        beta_fit : bool</span>
<span class="sd">            If True, include ``delta_beta`` in the foreground fitting parameters,</span>
<span class="sd">            along with the foreground amplitudes.</span>
<span class="sd">        bin_width_fg : int or list of ints</span>
<span class="sd">            Width of each foreground spectrum bin.  If a scalar, the same width</span>
<span class="sd">            is applied to all cross spectra.  Otherwise, must be a list of up to</span>
<span class="sd">            six elements, listing bin widths for the spectra in the order (TT,</span>
<span class="sd">            EE, BB, TE, EB, TB).</span>
<span class="sd">        lmin_fg : int</span>
<span class="sd">            Minimum ell to use for defining foreground bins.  If not set,</span>
<span class="sd">            defaults to ``lmin``.</span>
<span class="sd">        lmax_fg : int</span>
<span class="sd">            Maximum ell to use for defining foreground bins.  If not set,</span>
<span class="sd">            defaults to ``lmax``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_def : dict</span>
<span class="sd">            The bin definition dictionary.  Each key contains a Nx2 array</span>
<span class="sd">            that defines the left and right edges for each bin of the</span>
<span class="sd">            corresponding spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="o">=</span> <span class="n">pol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="o">=</span> <span class="n">pol_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># count all the things</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_spec</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_spec_mask</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">num_corr</span><span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol_mask</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_kern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_spec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_corr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_spec_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kern_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_kern</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">npol</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="k">if</span> <span class="n">tbeb</span> <span class="k">else</span> <span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">,</span> <span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">][:</span><span class="n">npol</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_width</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bin_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width</span><span class="p">]</span> <span class="o">*</span> <span class="n">npol</span>
        <span class="n">bin_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:</span><span class="n">npol</span><span class="p">]</span>

        <span class="n">bwerr</span> <span class="o">=</span> <span class="s2">&quot;EE and BB must have the same bin width (for mixing)&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="n">bin_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bin_width</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bwerr</span><span class="p">)</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">signal_comps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Define bins</span>
        <span class="n">nbins_cmb</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bin_def</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">nbins_cmb</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>
        <span class="n">signal_comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> CMB bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_cmb</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="c1"># Do the same for foreground bins</span>
        <span class="n">nbins_fg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">foreground_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width_fg</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_width_fg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bin_width_fg</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width_fg</span><span class="p">]</span> <span class="o">*</span> <span class="n">npol</span>
            <span class="n">bin_width_fg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width_fg</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:</span><span class="n">npol</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="n">bin_width_fg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">bin_width_fg</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Foreground </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bwerr</span><span class="p">))</span>

            <span class="n">lmin_fg</span> <span class="o">=</span> <span class="n">lmin_fg</span> <span class="ow">or</span> <span class="n">lmin</span>
            <span class="k">assert</span> <span class="n">lmin_fg</span> <span class="o">&gt;=</span> <span class="n">lmin</span>
            <span class="n">lmax_fg</span> <span class="o">=</span> <span class="n">lmax_fg</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
            <span class="k">assert</span> <span class="n">lmax_fg</span> <span class="o">&lt;=</span> <span class="n">lmax</span>

            <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">bin_width_fg</span><span class="p">):</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin_fg</span><span class="p">,</span> <span class="n">lmax_fg</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">lmax_fg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="n">nbins_fg</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">beta_fit</span><span class="p">:</span>
                <span class="n">bin_def</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>
            <span class="n">signal_comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> foreground bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_fg</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">beta_fit</span><span class="p">)),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Do the same for residual bins</span>
        <span class="n">nbins_res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">residual_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res_specs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res_specs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eebb&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">]</span>
            <span class="n">res_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">res_specs</span><span class="p">]</span>
            <span class="n">nmap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">)</span>
            <span class="n">nspecr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_specs</span><span class="p">)</span> <span class="o">*</span> <span class="n">nmap</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bin_width_res</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_width_res</span><span class="p">]</span> <span class="o">*</span> <span class="n">nspecr</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)</span> <span class="o">==</span> <span class="n">nspecr</span> <span class="o">//</span> <span class="n">nmap</span><span class="p">:</span>
                <span class="n">bin_width_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bin_width_res</span><span class="p">]</span> <span class="o">*</span> <span class="n">nmap</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">bin_width_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_width_res</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:</span><span class="n">nspecr</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmap</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">bws</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span> <span class="n">bin_width_res</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="ow">and</span> <span class="s2">&quot;ee&quot;</span> <span class="ow">in</span> <span class="n">res_specs</span> <span class="ow">and</span> <span class="s2">&quot;bb&quot;</span> <span class="ow">in</span> <span class="n">res_specs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bws</span><span class="p">[</span><span class="n">res_specs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ee&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">bws</span><span class="p">[</span><span class="n">res_specs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">)]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Residual </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">bwerr</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">bw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res_specs</span><span class="p">,</span> <span class="n">bws</span><span class="p">):</span>
                    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">btag</span> <span class="o">=</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
                    <span class="n">bin_def</span><span class="p">[</span><span class="n">btag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                    <span class="n">nbins_res</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Added </span><span class="si">{}</span><span class="s2"> residual bins to bin_def&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbins_res</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">lfac</span> <span class="o">=</span> <span class="n">ell</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">bin_weights</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">bd</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weighted_bins</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">lfac</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lfac</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="o">=</span> <span class="n">lmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_cmb</span> <span class="o">=</span> <span class="n">nbins_cmb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_fg</span> <span class="o">=</span> <span class="n">nbins_fg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">nbins_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span> <span class="o">=</span> <span class="n">bin_def</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span> <span class="o">=</span> <span class="n">weighted_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span> <span class="o">=</span> <span class="n">bin_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">comps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span> <span class="o">=</span> <span class="n">signal_comps</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span></div>

<div class="viewcode-block" id="XFaster.kernel_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.kernel_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">kernel_precalc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mixing kernels M_ll&#39; = K_ll&#39; * F_l&#39; * B_l&#39;^2.  Called by</span>
<span class="sd">        ``bin_cl_template`` to pre-compute kernel terms.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If supplied, the kernels are computed only for the given map tag</span>
<span class="sd">            (or cross if map_tag is map_tag1:map_tag2).</span>
<span class="sd">            Otherwise, it is computed for all maps and crosses.</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, set transfer function to 1 to solve for transfer function</span>
<span class="sd">            qbs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mll : OrderedDict</span>
<span class="sd">            Dictionary of M_ll&#39; matrices, keyed by component spec and xname.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">map_tag</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]}</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
            <span class="n">map_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>  <span class="c1"># 2 * lmax</span>

        <span class="n">lk</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
            <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">mll</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                <span class="n">mstag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_mix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stag</span><span class="p">)</span>
                <span class="n">mll</span><span class="p">[</span><span class="n">mstag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_windows</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
                <span class="n">tf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># beams</span>
                <span class="n">fb2</span> <span class="o">=</span> <span class="n">bw</span><span class="p">[</span><span class="n">m0</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span> <span class="o">*</span> <span class="n">bw</span><span class="p">[</span><span class="n">m1</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>

                <span class="c1"># transfer function</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="n">fb2</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tf</span><span class="p">[</span><span class="n">m0</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span> <span class="o">*</span> <span class="n">tf</span><span class="p">[</span><span class="n">m1</span><span class="p">][</span><span class="n">lk</span><span class="p">])</span>

                <span class="c1"># kernels</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                    <span class="n">mk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;te&quot;</span><span class="p">,</span> <span class="s2">&quot;tb&quot;</span><span class="p">]:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;eb&quot;</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mkern</span><span class="p">[</span><span class="n">xname</span><span class="p">][:,</span> <span class="n">lk</span><span class="p">]</span>

                <span class="c1"># store final product</span>
                <span class="n">mll</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">fb2</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mll</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mk</span> <span class="o">*</span> <span class="n">fb2</span>

        <span class="k">return</span> <span class="n">mll</span></div>

<div class="viewcode-block" id="XFaster.bin_cl_template"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.bin_cl_template">[docs]</a>    <span class="k">def</span> <span class="nf">bin_cl_template</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cls_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">beam_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_precalc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Cbl matrix from the input shape spectrum.</span>

<span class="sd">        This method requires beam windows, kernels and transfer functions</span>
<span class="sd">        (if ``transfer`` is False) to have been precomputed.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cls_shape : array_like</span>
<span class="sd">            The shape spectrum to use.  This can be computed using</span>
<span class="sd">            ``get_signal_shape`` or otherwise.</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If supplied, the Cbl is computed only for the given map tag</span>
<span class="sd">            (or cross if map_tag is map_tag1:map_tag2).</span>
<span class="sd">            Otherwise, it is computed for all maps and crosses.</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, this assumes a unity transfer function for all bins, and</span>
<span class="sd">            the output Cbl is used to compute the transfer functions that are</span>
<span class="sd">            then loaded when this method is called with ``transfer = False``.</span>
<span class="sd">        beam_error : bool</span>
<span class="sd">            If True, use beam error envelope instead of beam to get cbls that</span>
<span class="sd">            are 1 sigma beam error envelope offset of signal terms.</span>
<span class="sd">        use_precalc : bool</span>
<span class="sd">            If True, load pre-calculated terms stored from a previous iteration,</span>
<span class="sd">            and store for a future iteration.  Otherwise, all calculations are</span>
<span class="sd">            repeated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cbl : dict of arrays (num_bins, 2, lmax + 1)</span>
<span class="sd">            The Cbl matrix, indexed by component and spectrum, then by map</span>
<span class="sd">            cross, e.g. ``cbl[&#39;cmb_tt&#39;][&#39;map1:map2&#39;]``.  E/B mixing terms are</span>
<span class="sd">            stored in elements ``cbl[&#39;cmb_ee_mix&#39;]`` and ``cbl[&#39;cmb_bb_mix&#39;]``,</span>
<span class="sd">            and unmixed terms are stored in elements ``cbl[&#39;cmb_ee&#39;]`` and</span>
<span class="sd">            ``cbl[&#39;cmb_bb&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cls_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span>

        <span class="n">map_pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">map_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">map_tag</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]}</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">map_tag</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>

        <span class="k">if</span> <span class="n">map_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;eb&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">specs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;tb&quot;</span><span class="p">)</span>

        <span class="n">lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span>
        <span class="n">lmax_kern</span> <span class="o">=</span> <span class="n">lmax</span>  <span class="c1"># 2 * self.lmax</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mll&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_precalc</span><span class="p">:</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_precalc</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_precalc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mll</span>

        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
            <span class="n">beam_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_beam_errors</span><span class="p">()</span>
            <span class="n">beam_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">,</span> <span class="s2">&quot;b2&quot;</span><span class="p">,</span> <span class="s2">&quot;b3&quot;</span><span class="p">]</span>

        <span class="n">ls</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">lk</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cbl</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls_shape</span><span class="p">]):</span>
                <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">comp</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span> <span class="ow">and</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">comps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;fg&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>
            <span class="n">cls_noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span>
            <span class="n">cls_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_res_null</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_res</span>

        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">binup</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">binup2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">binup</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># convert to matrices to speed up multiplication and binning</span>
        <span class="n">nxmap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">)</span>
        <span class="n">dshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">nxmap</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">d_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;ee&quot;</span> <span class="ow">in</span> <span class="n">specs</span> <span class="ow">and</span> <span class="s2">&quot;bb&quot;</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="n">md_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span>

        <span class="n">cshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">nxmap</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lmax_kern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">s_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
            <span class="n">b_arr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cshape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                    <span class="c1"># clear arrays</span>
                    <span class="n">d_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="n">md_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">s_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b_arr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">tag1</span><span class="p">,</span> <span class="n">tag2</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">spec</span>
                        <span class="n">bd</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="c1"># if any component of XY spec is in residual bin def,</span>
                        <span class="c1"># use that bin def</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span>
                            <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                            <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                        <span class="p">]:</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                                <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                                <span class="k">break</span>
                            <span class="n">spec0</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">spec0</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">spec0</span><span class="p">,</span> <span class="s2">&quot;eebb&quot;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                                    <span class="k">break</span>

                        <span class="n">comp_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;res&quot;</span><span class="p">,</span> <span class="n">cls_noise</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span>
                            <span class="p">(</span><span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">cls_res</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls_res</span>
                        <span class="p">]</span>

                        <span class="k">for</span> <span class="n">res_comp</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">comp_list</span><span class="p">:</span>
                            <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                            <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">),</span> <span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
                                <span class="n">lls</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                                <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">idx</span><span class="p">,</span> <span class="n">lls</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">cl1</span><span class="p">[</span><span class="n">lls</span><span class="p">])</span>

                        <span class="k">continue</span>

                    <span class="c1"># use correct shape spectrum</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                        <span class="n">freq_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">s_arr</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_scale</span> <span class="o">*</span> <span class="n">cls_shape</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">s_arr</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_shape</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>

                    <span class="c1"># use correct beam error shape</span>
                    <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                        <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">][</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_error</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">tag1</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>
                        <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">][</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_error</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">tag2</span><span class="p">][</span><span class="n">lk</span><span class="p">]</span>

                    <span class="c1"># apply cross spectrum kernel terms</span>
                    <span class="n">d_arr</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">ls</span><span class="p">,</span> <span class="n">lk</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="n">mstag</span> <span class="o">=</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span>
                        <span class="n">md_arr</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">ls</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">ls</span><span class="p">,</span> <span class="n">lk</span><span class="p">]</span>

                <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

                <span class="c1"># mixing terms</span>
                <span class="n">mstag</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mstag</span> <span class="o">=</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span>
                    <span class="n">cbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">mstag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>

                <span class="c1"># multiply all the things</span>
                <span class="n">d_arr</span> <span class="o">*=</span> <span class="n">s_arr</span>
                <span class="k">if</span> <span class="n">mstag</span><span class="p">:</span>
                    <span class="n">md_arr</span> <span class="o">*=</span> <span class="n">s_arr</span>

                <span class="c1"># bin all the things</span>
                <span class="k">if</span> <span class="n">beam_error</span><span class="p">:</span>
                    <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b3&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">beam_keys</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">binup2</span><span class="p">(</span><span class="n">d_arr</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mstag</span><span class="p">:</span>
                            <span class="n">md</span> <span class="o">=</span> <span class="n">binup2</span><span class="p">(</span><span class="n">md_arr</span> <span class="o">*</span> <span class="n">b_arr</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">mstag</span><span class="p">:</span>
                                <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">binup2</span><span class="p">(</span><span class="n">d_arr</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mstag</span><span class="p">:</span>
                        <span class="n">md</span> <span class="o">=</span> <span class="n">binup2</span><span class="p">(</span><span class="n">md_arr</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">xname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_pairs</span><span class="p">):</span>
                        <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">mstag</span><span class="p">:</span>
                            <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cbl</span></div>

<div class="viewcode-block" id="XFaster.get_model_spectra"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_model_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute unbinned model spectra from qb amplitudes and a Cbl matrix.</span>
<span class="sd">        Requires pre-loaded bin definitions using ``get_bin_def`` or</span>
<span class="sd">        ``get_transfer``.</span>

<span class="sd">        This method is used internally by ``fisher_calc``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : dict of arrays</span>
<span class="sd">            Array of bandpowers for every spectrum bin.</span>
<span class="sd">        cbl : dict</span>
<span class="sd">            Cbl dict as computed by ``bin_cl_template``.</span>
<span class="sd">        cls_noise : OrderedDict</span>
<span class="sd">            If supplied, the noise spectrum is applied to the model spectrum.</span>
<span class="sd">        cond_noise : float</span>
<span class="sd">            Conditioning noise amplitude to add to TT, EE and BB autospectra,</span>
<span class="sd">            to improve convergence of the fisher iterations.  The noise model</span>
<span class="sd">            is constant cond_noise for EE, BB and 10x that for TT.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls : dict of arrays</span>
<span class="sd">            Model spectra.  Keyed by spectrum type, e.g. &#39;total_xx&#39; for the</span>
<span class="sd">            total model spectrom, &#39;fg_xx&#39; for the foreground terms, &#39;res_xx&#39; for</span>
<span class="sd">            the residual (noise) terms, where &#39;xx&#39; is one of the six power</span>
<span class="sd">            spectrum components (tt, ee, bb, te, eb, tb).  Each entry in the</span>
<span class="sd">            dictionary is itself a dictionary keyed by map cross, e.g.</span>
<span class="sd">            &#39;map1:map1&#39; for an autospectrum term, &#39;map1:map2&#39; for a cross</span>
<span class="sd">            spectrum, etc, and the map names are the same as those in the</span>
<span class="sd">            ``map_tags`` attribute.  Each individual spectrum is an array of</span>
<span class="sd">            length ``lmax + 1``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">]):</span>
                <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">comp</span><span class="p">]</span>

        <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
            <span class="c1"># Evaluate fg at spectral index pivot for derivative</span>
            <span class="c1"># in Fisher matrix, unless delta is True</span>
            <span class="n">delta_beta</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;noise&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cond_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">cond_noise</span>
            <span class="n">cls_cond</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">comps</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one model component&quot;</span><span class="p">)</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t add entries that won&#39;t be filled in later</span>
                    <span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                    <span class="n">mstag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cond&quot;</span><span class="p">:</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comp</span> <span class="ow">and</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">)</span>  <span class="c1"># list(cbl[stag])</span>

                <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="n">tag1</span><span class="p">,</span> <span class="n">tag2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>

                    <span class="c1"># extract qb&#39;s for the component spectrum</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">and</span> <span class="n">delta_beta</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">qbs</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">qbm</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">mstag</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">and</span> <span class="n">delta_beta</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="c1"># beta scaling for foreground model</span>
                        <span class="c1"># beta_scale = self.fg_scales[xname][1] ** delta_beta</span>
                        <span class="n">beta_scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta_beta</span>
                        <span class="n">qbs</span> <span class="o">=</span> <span class="n">beta_scale</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">qbm</span> <span class="o">=</span> <span class="n">beta_scale</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="n">mstag</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span>
                        <span class="c1"># modify model by previously fit res, including</span>
                        <span class="c1"># off diagonals and SXN/NXS for nulls</span>
                        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">spec</span>  <span class="c1"># separate qbs for, eg, TE resTT and resEE</span>
                        <span class="n">res_tags</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;s0m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;s0m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                            <span class="s2">&quot;s1m0&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag1</span><span class="p">),</span>
                            <span class="s2">&quot;s1m1&quot;</span><span class="p">:</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tag2</span><span class="p">),</span>
                        <span class="p">}</span>
                        <span class="n">qbr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s0m0&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s0m1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s1m0&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s1m1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">res_tags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                                <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="n">v</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">spec0</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">spec0</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                                    <span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">spec0</span><span class="p">,</span> <span class="s2">&quot;eebb&quot;</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                                        <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">qb</span><span class="p">[</span><span class="n">res_tags</span><span class="p">[</span><span class="n">k</span><span class="p">]])[:,</span> <span class="kc">None</span><span class="p">]</span>

                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">])):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                    <span class="s2">&quot;Unphysical residuals fit, &quot;</span>
                                    <span class="s2">&quot;setting to zero </span><span class="si">{}</span><span class="s2"> bins </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">spec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                                <span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qbr</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="n">res_list</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">(</span><span class="s2">&quot;s0m0&quot;</span><span class="p">,</span> <span class="s2">&quot;s1m1&quot;</span><span class="p">,</span> <span class="s2">&quot;nxn0&quot;</span><span class="p">),</span>  <span class="c1"># N_s0m0 x N_s1m1</span>
                            <span class="p">(</span><span class="s2">&quot;s1m0&quot;</span><span class="p">,</span> <span class="s2">&quot;s0m1&quot;</span><span class="p">,</span> <span class="s2">&quot;nxn1&quot;</span><span class="p">),</span>  <span class="c1"># N_s1m0 x N_s0m1</span>
                        <span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
                            <span class="n">res_list</span> <span class="o">+=</span> <span class="p">[</span>
                                <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;s1m1&quot;</span><span class="p">,</span> <span class="s2">&quot;sxn0&quot;</span><span class="p">),</span>  <span class="c1"># S_s0m0 x N_s1m1</span>
                                <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;s0m1&quot;</span><span class="p">,</span> <span class="s2">&quot;sxn1&quot;</span><span class="p">),</span>  <span class="c1"># S_s1m0 x N_s0m1</span>
                                <span class="p">(</span><span class="s2">&quot;s0m0&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;nxs0&quot;</span><span class="p">),</span>  <span class="c1"># N_s0m0 x S_s1m1</span>
                                <span class="p">(</span><span class="s2">&quot;s1m0&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;nxs1&quot;</span><span class="p">),</span>  <span class="c1"># N_s1m0 x S_s0m1</span>
                            <span class="p">]</span>

                        <span class="n">cl1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cl1</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">k3</span> <span class="ow">in</span> <span class="n">res_list</span><span class="p">:</span>
                            <span class="n">q1</span> <span class="o">=</span> <span class="n">qbr</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="k">if</span> <span class="n">k1</span> <span class="k">else</span> <span class="mf">1.0</span>
                            <span class="n">q2</span> <span class="o">=</span> <span class="n">qbr</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="k">if</span> <span class="n">k2</span> <span class="k">else</span> <span class="mf">1.0</span>
                            <span class="n">rtag</span> <span class="o">=</span> <span class="s2">&quot;res_</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k3</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                            <span class="n">cl1</span> <span class="o">+=</span> <span class="p">((</span><span class="n">q1</span> <span class="o">*</span> <span class="n">q2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">cbl</span><span class="p">[</span><span class="n">rtag</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># all of these were asymmetric specs, divide by 2 for mean</span>
                        <span class="n">cl1</span> <span class="o">/=</span> <span class="mf">2.0</span>

                    <span class="c1"># compute model spectra</span>
                    <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="n">cbl1</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbl1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="c1"># has beam error terms. deal with them individually</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cbl1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">cl1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">qbs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="p">(</span><span class="n">qbs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cbl1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="c1"># mixing terms, add in-place</span>
                            <span class="k">if</span> <span class="n">qbm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mstag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                                <span class="n">cbl1_mix</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">mstag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cbl1_mix</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cbl1_mix</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                        <span class="n">cl1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">qbm</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">cl1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">qbm</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cbl1_mix</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
                        <span class="n">cl1</span> <span class="o">=</span> <span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">][:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">elif</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;cond&quot;</span><span class="p">:</span>
                        <span class="c1"># add conditioner along diagonal</span>
                        <span class="k">if</span> <span class="n">tag1</span> <span class="o">!=</span> <span class="n">tag2</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;tt&quot;</span><span class="p">:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">cls_cond</span>
                        <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">cl1</span> <span class="o">=</span> <span class="n">cls_cond</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="c1"># store</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">stag</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl1</span>

                    <span class="c1"># add to total model</span>
                    <span class="n">ttag</span> <span class="o">=</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="bp">cls</span><span class="p">[</span><span class="n">ttag</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cl1</span><span class="p">))</span>
                    <span class="bp">cls</span><span class="p">[</span><span class="n">ttag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cl1</span>

        <span class="k">return</span> <span class="bp">cls</span></div>

<div class="viewcode-block" id="XFaster.get_data_spectra"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_data_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_data_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">do_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data and noise spectra for the given map tag(s).  Data spectra</span>
<span class="sd">        and signal/noise sim spectra must have been precomputed or loaded from</span>
<span class="sd">        disk.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If None, all map-map cross-spectra are included in the outputs.</span>
<span class="sd">            Otherwise, only the autospectra of the given map are included.</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, the data cls are the average of the signal simulations, and</span>
<span class="sd">            noise cls are ignored.  If False, the data cls are either</span>
<span class="sd">            ``cls_data_null`` (for null tests) or ``cls_data``.  See</span>
<span class="sd">            ``get_masked_data`` for how these are computed.  The input noise is</span>
<span class="sd">            similarly either ``cls_noise_null`` or ``cls_noise``.</span>
<span class="sd">        do_noise : bool</span>
<span class="sd">            If True, return noise spectra and debiased spectra along with data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obs : OrderedDict</span>
<span class="sd">            Dictionary of data cross spectra</span>
<span class="sd">        nell : OrderedDict</span>
<span class="sd">            Dictionary of noise cross spectra, or None if ``transfer`` is True.</span>
<span class="sd">        debias : OrderedDict</span>
<span class="sd">            Dictionary of debiased data cross spectra, or None if ``transfer``</span>
<span class="sd">            is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># select map pairs</span>
        <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_tag</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
        <span class="n">map_pairs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">tag_pairs</span><span class="p">(</span><span class="n">map_tags</span><span class="p">)</span>

        <span class="c1"># select spectra</span>
        <span class="n">tbeb</span> <span class="o">=</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span>
        <span class="k">if</span> <span class="n">transfer</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">tbeb</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span>

        <span class="c1"># obs depends on what you&#39;re computing</span>
        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_sub_null</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_null</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data_clean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obs_quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_data</span>

        <span class="c1"># in case we&#39;re excluding some spectra or maps, repopulate obs dict</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
            <span class="n">obs</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="p">:</span>
                <span class="n">obs</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_quant</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_noise</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obs</span>

        <span class="k">elif</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">nell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">debias</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># Nulls are debiased by average of S+N sims</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="p">:</span>
                    <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># signal term already subtracted with reference maps</span>
                        <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_sim_null</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>

        <span class="c1"># Non-nulls are debiased by average of N sims</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_run</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">m0</span> <span class="o">!=</span> <span class="n">m1</span><span class="p">:</span>
                        <span class="c1"># set non-auto noise to 0-- don&#39;t care to fit cross</span>
                        <span class="c1"># spectrum noise</span>
                        <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>
                    <span class="n">debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nell</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">nell</span> <span class="o">=</span> <span class="n">debias</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="n">nell</span><span class="p">,</span> <span class="n">debias</span></div>

<div class="viewcode-block" id="XFaster.do_qb2cb"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.do_qb2cb">[docs]</a>    <span class="k">def</span> <span class="nf">do_qb2cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">wbl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute binned output spectra and covariances by averaging</span>
<span class="sd">        the shape spectrum over each bin, and applying the appropriate</span>
<span class="sd">        ``qb`` bandpower amplitude.</span>

<span class="sd">        This method is used internally by ``fisher_calc``, and requires</span>
<span class="sd">        bin definitions to have been pre-loaded using ``get_bin_def``</span>
<span class="sd">        or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : dict</span>
<span class="sd">            Bandpower amplitudes for each spectrum bin.</span>
<span class="sd">        inv_fish : array_like, (nbins, nbins)</span>
<span class="sd">            Inverse fisher matrix for computing the bin errors and covariance.</span>
<span class="sd">        wbl : dict</span>
<span class="sd">            Window functions for each qb</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cb : dict of arrays</span>
<span class="sd">            Binned spectrum</span>
<span class="sd">        dcb : dict of arrays</span>
<span class="sd">            Binned spectrum error</span>
<span class="sd">        ellb : dict of arrays</span>
<span class="sd">            Average bin center</span>
<span class="sd">        cov : array_like, (nbins, nbins)</span>
<span class="sd">            Binned spectrum covariance</span>
<span class="sd">        qb2cb : dict</span>
<span class="sd">            The conversion matrix from ``qb`` to ``cb`` for each spectrum</span>
<span class="sd">            component, computed from the qb window functions</span>
<span class="sd">        wbl_cb : dict</span>
<span class="sd">            Window functions for each cb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qb2cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">ellb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">wbl_cb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># truncate to only bins for which there are window functions</span>
        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">wbl</span><span class="p">])</span>
        <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">inv_fish</span><span class="p">[:</span><span class="n">nbins</span><span class="p">,</span> <span class="p">:</span><span class="n">nbins</span><span class="p">]</span>
        <span class="n">qb2cb_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span>

        <span class="c1"># window function normalization</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ell</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># normalization shape spectrum</span>
        <span class="n">model</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_cls</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">ell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">ell</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">wbl1</span> <span class="ow">in</span> <span class="n">wbl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># compute conversion factors</span>
            <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">wbl1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">wbl1</span><span class="p">)))</span>
            <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">[</span><span class="n">stag</span><span class="p">][:</span> <span class="nb">len</span><span class="p">(</span><span class="n">ell</span><span class="p">)]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">wbl1</span> <span class="o">*</span> <span class="n">cls_shape</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">bw</span><span class="p">)):</span>
                <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">][:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># normalize for cb&#39;s or db&#39;s</span>
            <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl1</span> <span class="o">*</span> <span class="n">model</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># construct conversion matrix for covariance</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
            <span class="n">qb2cb_mat</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>

            <span class="c1"># compute wbls for cb&#39;s</span>
            <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,jl-&gt;il&quot;</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">wbl1</span><span class="p">)</span>

            <span class="c1"># check normalization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> cb window function normalization: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">stag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># compute bin centers</span>
            <span class="n">ellb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">wbl_cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="n">ell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># compute cb&#39;s</span>
            <span class="n">cb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span>

        <span class="c1"># compute covariance and errors</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ik,jl,kl-&gt;ij&quot;</span><span class="p">,</span> <span class="n">qb2cb_mat</span><span class="p">,</span> <span class="n">qb2cb_mat</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">)</span>
        <span class="n">dcb</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">)),</span> <span class="n">qb2cb</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cb</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">ellb</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">,</span> <span class="n">wbl_cb</span></div>

<div class="viewcode-block" id="XFaster.fisher_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_precalc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">cls_input</span><span class="p">,</span>
        <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-compute the D_ell and signal derivative matrices necessary for</span>
<span class="sd">        ``fisher_calc`` from the input data spectra.  This method requires bin</span>
<span class="sd">        definitions precomputed by ``get_bin_def`` or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl dict computed by ``bin_cl_template`` for a given</span>
<span class="sd">            shape spectrum.</span>
<span class="sd">        cls_input : OrderedDict</span>
<span class="sd">            Input spectra.  If computing a transfer function, this is the</span>
<span class="sd">            average ``cls_signal``.  If computing a null test, this is</span>
<span class="sd">            ``cls_data_null``, and otherwise it is ``cls_data``, for a single map or</span>
<span class="sd">            several input maps.</span>
<span class="sd">        cls_debias : OrderedDict</span>
<span class="sd">            If supplied, the debias spectrum is subtracted from the input.</span>
<span class="sd">        likelihood : bool</span>
<span class="sd">            If True, compute just Dmat_obs_b.  Otherwise, Dmat_obs and</span>
<span class="sd">            dSdqb_mat1 are also computed.</span>
<span class="sd">        windows : bool</span>
<span class="sd">            If True, compute dSdqb and Mll for constructing window functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dmat_obs : OrderedDict</span>
<span class="sd">            De-biased D_ell matrix from ``cls_input``</span>
<span class="sd">        Dmat_obs_b : OrderedDict</span>
<span class="sd">            Biased D_ell matrix from ``cls_input`` (for likelihood)</span>
<span class="sd">        dSdqb_mat1 : OrderedDict</span>
<span class="sd">            Signal derivative matrix from Cbl</span>
<span class="sd">        Mmat : OrderedDict</span>
<span class="sd">            Mode mixing matrix (Kll&#39; * Fl * Bl^2) for constructing</span>
<span class="sd">            window functions.</span>

<span class="sd">        .. note:: the output arrays are also stored as attributes of the</span>
<span class="sd">        parent object to avoid repeating the computation in ``fisher_calc``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="n">pol_dim</span> <span class="o">*</span> <span class="n">num_maps</span>

        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sig_comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comp</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">]):</span>
                <span class="n">comps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">comp</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                    <span class="n">sig_comps</span> <span class="o">+=</span> <span class="p">[</span><span class="n">comp</span><span class="p">]</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_input</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dSdqb</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Mmat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">sig_comps</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                        <span class="n">Mmat</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">mll</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mll&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mll</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_precalc</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">Mmat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dSdqb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transfer function doesn&#39;t have all the crosses</span>
            <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">specs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">windows</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">sig_comps</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                        <span class="n">Mmat</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                    <span class="c1"># without bias subtraction for likelihood</span>
                    <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">windows</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">sig_comps</span><span class="p">:</span>
                        <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                        <span class="n">Mmat</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                            <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span>
                            <span class="n">Mmat</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">mspec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mll</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_mix&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stag</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cls_debias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">-</span> <span class="n">cls_debias</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Dmat_obs</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_input</span><span class="p">[</span><span class="n">spec</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">dSdqb</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                        <span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">dSdqb</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cbl</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">mspec</span> <span class="o">=</span> <span class="s2">&quot;bb&quot;</span> <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;ee&quot;</span> <span class="k">else</span> <span class="s2">&quot;ee&quot;</span>
                        <span class="n">mix_cbl</span> <span class="o">=</span> <span class="n">cbl</span><span class="p">[</span><span class="n">stag</span> <span class="o">+</span> <span class="s2">&quot;_mix&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="n">dSdqb</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">][</span><span class="n">mspec</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_cbl</span>

        <span class="k">return</span> <span class="n">Dmat_obs</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">,</span> <span class="n">dSdqb</span><span class="p">,</span> <span class="n">Mmat</span></div>

<div class="viewcode-block" id="XFaster.clear_precalc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.clear_precalc">[docs]</a>    <span class="k">def</span> <span class="nf">clear_precalc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear variables pre-computed with ``fisher_precalc``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Dmat_obs&quot;</span><span class="p">,</span> <span class="s2">&quot;Dmat_obs_b&quot;</span><span class="p">,</span> <span class="s2">&quot;dSdqb_mat1&quot;</span><span class="p">,</span> <span class="s2">&quot;Mmat&quot;</span><span class="p">,</span> <span class="s2">&quot;mll&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.fisher_calc"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_calc">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_calc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qb</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">cls_input</span><span class="p">,</span>
        <span class="n">cls_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cls_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_lmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">like_lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_precalc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">inv_fish</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-compute the Fisher matrix and qb amplitudes based on</span>
<span class="sd">        input data spectra.  This method is called iteratively</span>
<span class="sd">        by ``fisher_iterate``, and requires bin definitions precomputed</span>
<span class="sd">        by ``get_bin_def`` or ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            Bandpower amplitudes, typically computed in a previous call</span>
<span class="sd">            to this method.</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl matrix computed by ``bin_cl_template`` for a given</span>
<span class="sd">            shape spectrum.</span>
<span class="sd">        cls_input : OrderedDict</span>
<span class="sd">            Input spectra.  If computing a transfer function,</span>
<span class="sd">            this is the average ``cls_signal``.  If computing a null</span>
<span class="sd">            test, this is ``cls_data_null``, and otherwise it is</span>
<span class="sd">            ``cls_data``, for a single map or several input maps.</span>
<span class="sd">        cls_noise : OrderedDict</span>
<span class="sd">            If supplied, the noise spectrum is applied to the model spectrum.</span>
<span class="sd">        cls_debias : OrderedDict</span>
<span class="sd">            If supplied, the debias spectrum is subtracted from the input.</span>
<span class="sd">        cls_model : OrderedDict</span>
<span class="sd">            Unbinned model spectrum computed from cbl</span>
<span class="sd">        cond_noise : float</span>
<span class="sd">            The level of regularizing noise to add to EE and BB diagonals.</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        likelihood : bool</span>
<span class="sd">            If True, return the likelihood for the given input bandpowers, shapes</span>
<span class="sd">            and data spectra.  Otherwise, computes output bandpowers and the fisher</span>
<span class="sd">            covariance for a NR iteration.</span>
<span class="sd">        like_lmin : int</span>
<span class="sd">            The minimum ell value to be included in the likelihood calculation</span>
<span class="sd">        like_lmax : int</span>
<span class="sd">            The maximum ell value to be included in the likelihood calculation</span>
<span class="sd">        delta_beta_prior : float</span>
<span class="sd">            The width of the prior on the additive change from beta_ref. If you</span>
<span class="sd">            don&#39;t want the code to fit for a spectral index different</span>
<span class="sd">            from beta_ref, set this to be a very small value (O(1e-10)).</span>
<span class="sd">        null_first_cmb : bool</span>
<span class="sd">            Keep first CMB bandpowers fixed to input shape (qb=1).</span>
<span class="sd">        use_precalc : bool</span>
<span class="sd">            If True, load pre-calculated terms stored from a previous iteration,</span>
<span class="sd">            and store for a future iteration.  Otherwise, all calculations are</span>
<span class="sd">            repeated.</span>
<span class="sd">        windows : bool</span>
<span class="sd">            If True, return W_bl window functions for each CMB qb.</span>
<span class="sd">        inv_fish : array_like</span>
<span class="sd">            Inverse Fisher matrix. If provided, don&#39;t need to recompute. Useful</span>
<span class="sd">            if just getting bandpower window functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            New bandpower amplitudes</span>
<span class="sd">        inv_fish : array_like</span>
<span class="sd">            Inverse Fisher correlation matrix over all bins</span>
<span class="sd">        -- or --</span>
<span class="sd">        likelihood : scalar</span>
<span class="sd">            Likelihood of the given input parameters.</span>
<span class="sd">        -- or --</span>
<span class="sd">        windows : OrderedDict</span>
<span class="sd">            qb window functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cond_criteria</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond_criteria</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">pol_dim</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pol</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">dkey</span> <span class="o">=</span> <span class="s2">&quot;Dmat_obs_b&quot;</span> <span class="k">if</span> <span class="n">likelihood</span> <span class="k">else</span> <span class="s2">&quot;Mmat&quot;</span> <span class="k">if</span> <span class="n">windows</span> <span class="k">else</span> <span class="s2">&quot;Dmat_obs&quot;</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dkey</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_precalc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_precalc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>
            <span class="n">Dmat_obs</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">,</span> <span class="n">dSdqb_mat1</span><span class="p">,</span> <span class="n">Mmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_precalc</span><span class="p">(</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">cls_input</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">cls_debias</span><span class="p">,</span>
                <span class="n">likelihood</span><span class="o">=</span><span class="n">likelihood</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">use_precalc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">Dmat_obs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">Dmat_obs_b</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="n">dSdqb_mat1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Mmat</span> <span class="o">=</span> <span class="n">Mmat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs_b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
                    <span class="n">Mmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mmat</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span>
                <span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dSdqb_mat1</span>

        <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>

        <span class="n">delta_beta</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
            <span class="n">delta_beta</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">likelihood</span> <span class="ow">or</span> <span class="n">windows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cond_noise</span><span class="p">:</span>
            <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">cond_noise</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">gmat_ell</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">cls_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span>
            <span class="p">)</span>

        <span class="n">mkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cls_model</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># transfer function does not have crosses</span>
            <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="k">continue</span>
            <span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">well_cond</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="c1"># transfer function doesn&#39;t have eb/tb</span>
                    <span class="k">if</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">Dmat1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">Dmat1</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">well_cond</span><span class="p">:</span>
            <span class="n">Dmat1_mat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat1</span><span class="p">)</span>

        <span class="c1"># Set up dSdqb spectral index dependence</span>
        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="c1"># don&#39;t make changes to cached matrix</span>
            <span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dSdqb_mat1</span><span class="p">)</span>
            <span class="n">dSdqb_mat1</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">xname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="p">:</span>
                <span class="c1"># transfer function does not have crosses</span>
                <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="k">continue</span>

                <span class="n">dSdqb_mat1</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

                <span class="c1"># Add spectral index dependence</span>
                <span class="c1"># dSdqb now depends on qb (spec index) because</span>
                <span class="c1"># model is non-linear so cannot be precomputed.</span>

                <span class="c1"># get foreground at pivot point spectral index</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">beta_scale</span><span class="p">,</span> <span class="n">log_beta_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span>
                <span class="c1"># separable beta correction</span>
                <span class="c1"># beta_scale = beta_scale ** delta_beta  # non-linear</span>
                <span class="n">beta_scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">log_beta_scale</span> <span class="o">*</span> <span class="n">delta_beta</span>  <span class="c1"># linear</span>
                <span class="n">beta_scale0</span> <span class="o">=</span> <span class="n">log_beta_scale</span> <span class="o">/</span> <span class="n">beta_scale</span>

                <span class="c1"># scale foreground model by frequency scaling adjusted for beta</span>
                <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">sdat</span> <span class="ow">in</span> <span class="n">dSdqb_mat1</span><span class="p">[</span><span class="s2">&quot;fg&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="n">sdat2</span> <span class="ow">in</span> <span class="n">sdat</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">sdat2</span> <span class="o">*=</span> <span class="n">beta_scale</span>

                    <span class="c1"># with linearized derivative term, evaluated at input beta</span>
                    <span class="n">dSdqb_mat1</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">s1</span><span class="p">:</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;fg_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span> <span class="o">*</span> <span class="n">beta_scale0</span><span class="p">}</span>
                    <span class="p">)</span>

        <span class="c1"># Set up Dmat -- if it&#39;s not well conditioned, add noise to the</span>
        <span class="c1"># diagonal until it is.</span>
        <span class="n">cond_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">well_cond</span><span class="p">:</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># transfer function does not have crosses</span>
                <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">[</span><span class="n">mkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="c1"># transfer function doesn&#39;t have eb/tb</span>
                    <span class="k">if</span> <span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cls_model</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">Dmat1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">xname</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
                    <span class="n">Dmat1</span><span class="p">[</span><span class="n">xname</span><span class="p">][</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_model</span><span class="p">[</span><span class="s2">&quot;total_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">xname</span><span class="p">]</span>

            <span class="n">Dmat1_mat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat1</span><span class="p">)</span>

            <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">Dmat1_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="p">:]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">cond</span> <span class="o">&gt;</span> <span class="n">cond_criteria</span> <span class="ow">and</span> <span class="n">cond_noise</span><span class="p">:</span>
                <span class="n">cond_iter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># cond_noise iteration factor found through trial and error</span>
                <span class="n">cond_noise</span> <span class="o">*=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">cond_iter</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cond_iter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Condition criteria not met. &quot;</span>
                        <span class="s2">&quot;Max Cond=</span><span class="si">{:.0f}</span><span class="s2">, Thresh=</span><span class="si">{:.0f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">),</span>
                        <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">well_cond</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Condition criteria met. &quot;</span>
                    <span class="s2">&quot;Max Cond=</span><span class="si">{:.0f}</span><span class="s2">, Thresh=</span><span class="si">{:.0f}</span><span class="s2">, Iter=</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">cond</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">,</span> <span class="n">cond_iter</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cond_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Cond_noise = </span><span class="si">{:.3e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond_noise</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>

        <span class="c1"># construct arrays from dictionaries</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">Dmat1_mat</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">gmat_ell</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat_obs_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Dmat_obs</span><span class="p">)</span>
            <span class="c1"># select only derivative terms for bins that are iterated</span>
            <span class="n">bin_def</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">])</span>
            <span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dsdqb_mat</span><span class="p">(</span><span class="n">dSdqb_mat1</span><span class="p">,</span> <span class="n">bin_def</span><span class="p">)</span>

        <span class="c1"># apply ell limits</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmin</span> <span class="k">if</span> <span class="n">like_lmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">like_lmin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">like_lmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">like_lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ell</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Dmat1</span> <span class="o">=</span> <span class="n">Dmat1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="n">Dmat_obs_b</span> <span class="o">=</span> <span class="n">Dmat_obs_b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span><span class="p">:</span>
                <span class="n">Dmat_obs</span> <span class="o">=</span> <span class="n">Dmat_obs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
            <span class="n">dSdqb_mat1</span> <span class="o">=</span> <span class="n">dSdqb_mat1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>
        <span class="n">gmat</span> <span class="o">=</span> <span class="n">gmat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">]</span>

        <span class="n">lam</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Dmat1</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">Dmat1</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">lam</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="c1"># exclude any ell&#39;s with ill-conditioned D matrix</span>
            <span class="c1"># this should happen only far from max like</span>
            <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bad</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">bad_ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ell</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ell</span><span class="o">.</span><span class="n">stop</span><span class="p">)[</span><span class="n">bad_idx</span><span class="p">]</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="p">(</span><span class="n">lam</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">bad_specs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tt&quot;</span><span class="p">,</span> <span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="p">)[</span><span class="n">bads</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Found negative eigenvalues in specs </span><span class="si">{}</span><span class="s2"> at ells </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">bad_specs</span><span class="p">,</span> <span class="n">bad_ells</span>
                <span class="p">),</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
                <span class="n">gmat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">inv_lam</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">lam</span>
        <span class="n">Dinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j,...kj-&gt;...ik&quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">inv_lam</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">inv_lam</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="c1"># log(det(D)) = tr(log(D)), latter is numerically stable</span>
            <span class="c1"># compute log(D) by eigenvalue decomposition per ell</span>
            <span class="n">log_lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">lam</span>
            <span class="n">Dlog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ij,...j,...kj-&gt;...ik&quot;</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">log_lam</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">R</span><span class="p">,</span> <span class="n">log_lam</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># optimized matrix multiplication</span>
            <span class="c1"># there is something super weird about this whole matrix operation</span>
            <span class="c1"># that causes the computation of mats to take four times as long</span>
            <span class="c1"># if mat1 is not computed.</span>
            <span class="k">del</span> <span class="n">lam</span><span class="p">,</span> <span class="n">R</span>
            <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gmat</span><span class="p">))</span>
            <span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij...,jk...-&gt;ik...&quot;</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
            <span class="n">mat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;klm...,ln...-&gt;knm...&quot;</span><span class="p">,</span> <span class="n">dSdqb_mat1</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">Dinv</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ik...,knm...-&gt;inm...&quot;</span><span class="p">,</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span>

        <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span>
            <span class="c1"># compute log likelihood as tr(g * (D^-1 * Dobs + log(D)))</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij...,jk...-&gt;ik...&quot;</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">Dlog</span>
            <span class="k">del</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">Dmat_obs_b</span><span class="p">,</span> <span class="n">Dlog</span>
            <span class="n">like</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iij,iij-&gt;&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="c1"># include priors in likelihood</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span> <span class="ow">and</span> <span class="n">delta_beta_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_beta</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta_beta_prior</span>
                <span class="n">like</span> <span class="o">-=</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">if</span> <span class="n">null_first_cmb</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span>
                    <span class="n">like</span> <span class="o">-=</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">return</span> <span class="n">like</span>

        <span class="c1"># construct matrices for the qb and fisher terms,</span>
        <span class="c1"># and take the trace and sum over ell simultaneously</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span> <span class="ow">or</span> <span class="p">(</span><span class="n">windows</span> <span class="ow">and</span> <span class="n">inv_fish</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jiml-&gt;km&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">dSdqb_mat1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">del</span> <span class="n">dSdqb_mat1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">windows</span><span class="p">:</span>
            <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jil-&gt;k&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">Dmat_obs</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">del</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">Dmat_obs</span>

        <span class="k">if</span> <span class="n">windows</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">inv_fish</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fisher</span><span class="p">)))</span>

            <span class="c1"># compute prefactors</span>
            <span class="n">ells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ells</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># compute binning term</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,kljm-&gt;klim&quot;</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">mat</span>
            <span class="n">wbl</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>

            <span class="c1"># compute foreground scaling per frequency</span>
            <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                <span class="n">fmat</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fg_scales</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">fmat</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="n">amp</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="n">amp</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">delta_beta</span> <span class="o">*</span> <span class="n">c</span>
                        <span class="c1"># amp *= b ** delta_beta</span>
                    <span class="n">fmat</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">])</span>
                <span class="n">fmat</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">fmat</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)</span>

            <span class="c1"># compute window functions for each spectrum</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bin_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Mmat</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># select bins for corresponding spectrum</span>
                <span class="n">sarg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>

                <span class="c1"># construct Mll&#39; matrix</span>
                <span class="n">marg</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_dmat</span><span class="p">(</span><span class="n">Mmat</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">pol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pol</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">ell</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># apply frequency scaling</span>
                <span class="k">if</span> <span class="n">comp</span> <span class="o">==</span> <span class="s2">&quot;fg&quot;</span><span class="p">:</span>
                    <span class="n">marg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ijlm-&gt;ijlm&quot;</span><span class="p">,</span> <span class="n">fmat</span><span class="p">,</span> <span class="n">marg</span><span class="p">)</span>

                <span class="c1"># qb window function</span>
                <span class="n">wbl1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;iil,ijkl,jilm-&gt;km&quot;</span><span class="p">,</span> <span class="n">gmat</span><span class="p">,</span> <span class="n">sarg</span><span class="p">,</span> <span class="n">marg</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">norm</span>
                <span class="k">del</span> <span class="n">marg</span>

                <span class="c1"># bin weighting, allowing for overlapping bin edges</span>
                <span class="n">chi_bl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">chi_bl</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span>

                <span class="c1"># check normalization</span>
                <span class="n">cls_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span> <span class="nb">len</span><span class="p">(</span><span class="n">norm</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> qb window function normalization: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wbl1</span> <span class="o">*</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">chi_bl</span> <span class="o">*</span> <span class="n">cls_shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">wbl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">wbl1</span>

            <span class="k">return</span> <span class="n">wbl</span>

        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span> <span class="ow">and</span> <span class="n">delta_beta_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># XXX need documentation for what happens here</span>
            <span class="c1"># for imposing the delta_beta prior</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">bin_index</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta_beta_prior</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">qb_vec</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">null_first_cmb</span><span class="p">:</span>
            <span class="c1"># blow up the fisher matrix for first bin</span>
            <span class="c1"># by implementing a tight prior</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">bin_index</span><span class="p">:</span>  <span class="c1"># check for transfer function</span>
                    <span class="n">b0</span> <span class="o">=</span> <span class="n">bin_index</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">fisher</span><span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e10</span>
                    <span class="n">qb_vec</span><span class="p">[</span><span class="n">b0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e10</span>

        <span class="c1"># invert</span>
        <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">qb_vec</span><span class="p">)</span>
        <span class="n">inv_fish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">fisher</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">)))</span>
        <span class="n">qb_vec</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">qb_vec</span><span class="p">,</span> <span class="n">qb</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">qb_vec</span><span class="p">,</span> <span class="n">inv_fish</span></div>

<div class="viewcode-block" id="XFaster.fisher_iterate"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.fisher_iterate">[docs]</a>    <span class="k">def</span> <span class="nf">fisher_iterate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cbl</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">qb_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">like_profiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profile_sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">like_profile_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the Fisher calculation to compute bandpower estimates</span>
<span class="sd">        assuming an input shape spectrum.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        cbl : OrderedDict</span>
<span class="sd">            Cbl matrix computed from an input shape spectrum</span>
<span class="sd">        map_tag : str</span>
<span class="sd">            If not None, then iteration is performed over the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra. In this case, the first</span>
<span class="sd">            dimension of the input cbl must be of size 1 (this is done</span>
<span class="sd">            automatically by calling ``bin_cl_template(..., map_tag=&lt;map_tag&gt;)``.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is</span>
<span class="sd">            reached, a warning is issued.</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and</span>
<span class="sd">            stops iteration.</span>
<span class="sd">        qb_start : OrderedDict</span>
<span class="sd">            Initial guess at ``qb`` bandpower amplitudes.  If None, unity is</span>
<span class="sd">            assumed for all bins.</span>
<span class="sd">        transfer : bool</span>
<span class="sd">            If True, the input Cls passed to ``fisher_calc`` are the average</span>
<span class="sd">            of the signal simulations, and noise cls are ignored.</span>
<span class="sd">            If False, the input Cls are either ``cls_data_null``</span>
<span class="sd">            (for null tests) or ``cls_data``.  See ``get_masked_data`` for</span>
<span class="sd">            how these are computed.  The input noise is similarly either</span>
<span class="sd">            ``cls_noise_null`` or ``cls_noise``.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored</span>
<span class="sd">            in an individual npz file.</span>
<span class="sd">        null_first_cmb : bool</span>
<span class="sd">            Keep first CMB bandpowers fixed to input shape (qb=1).</span>
<span class="sd">        delta_beta_prior : float</span>
<span class="sd">            The width of the prior on the additive change from beta_ref. If you</span>
<span class="sd">            don&#39;t want the code to fit for a spectral index different</span>
<span class="sd">            from beta_ref, set this to be a very small value (O(1e-10)).</span>
<span class="sd">        cond_noise : float</span>
<span class="sd">            The level of regularizing noise to add to EE and BB diagonals.</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        like_profiles : bool</span>
<span class="sd">            If True, compute profile likelihoods for each qb, leaving all</span>
<span class="sd">            others fixed at their maximum likelihood values.  Profiles are</span>
<span class="sd">            computed over a range +/--sigma as estimated from the diagonals</span>
<span class="sd">            of the inverse Fisher matrix.</span>
<span class="sd">        like_profile_sigma : float</span>
<span class="sd">            Range in units of 1sigma over which to compute profile likelihoods</span>
<span class="sd">        like_profile_points : int</span>
<span class="sd">            Number of points to sample along the likelihood profile</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the bandpowers filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            The results of the Fisher iteration process.  This dictionary</span>
<span class="sd">            contains the fields::</span>

<span class="sd">                qb : converged bandpower amplitudes</span>
<span class="sd">                cb : output binned spectrum</span>
<span class="sd">                dcb : binned spectrum errors</span>
<span class="sd">                ellb : bin centers</span>
<span class="sd">                cov : spectrum covariance</span>
<span class="sd">                inv_fish : inverse fisher matrix</span>
<span class="sd">                fqb : fractional change in qb for the last iteration</span>
<span class="sd">                qb2cb : conversion factor</span>
<span class="sd">                cbl : Cbl matrix</span>
<span class="sd">                cls_model : unbinned model spectrum computed from Cbl</span>
<span class="sd">                bin_def : bin definition array</span>
<span class="sd">                cls_obs : observed input spectra</span>
<span class="sd">                cls_noise : noise spectra</span>
<span class="sd">                cls_shape : shape spectrum</span>
<span class="sd">                iters : number of iterations completed</span>

<span class="sd">            If ``transfer`` is False, this dictionary also contains::</span>

<span class="sd">                qb_transfer : transfer function amplitudes</span>
<span class="sd">                transfer : ell-by-ell transfer function</span>
<span class="sd">                nbins_res : number of residual bins</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method stores outputs to files with name &#39;transfer&#39; for transfer</span>
<span class="sd">        function runs (if ``transfer = True``), otherwise with name</span>
<span class="sd">        &#39;bandpowers&#39;.  Outputs from each individual iteration, containing</span>
<span class="sd">        only the quantities that change with each step, are stored in</span>
<span class="sd">        separate files with the same name (and different index).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">null_first_cmb</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;transfer_wbins&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span> <span class="k">else</span> <span class="s2">&quot;transfer&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;bandpowers&quot;</span>

        <span class="c1"># previous fqb iterations to monitor convergence and adjust conditioning</span>
        <span class="n">prev_fqb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cond_adjusted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">qb_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;cmb&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="s2">&quot;eb&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="s2">&quot;tb&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;delta_beta&quot;</span><span class="p">:</span>
                    <span class="c1"># qb_delta beta is a coefficient on the change from beta,</span>
                    <span class="c1"># so expect that it should be small if beta_ref is close</span>
                    <span class="c1"># (zeroes cause singular matrix problems)</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">):</span>
                    <span class="c1"># res qb=0 means noise model is 100% accurate.</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># start by assuming model is 100% accurate</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">qb_start</span>

        <span class="n">obs</span><span class="p">,</span> <span class="n">nell</span><span class="p">,</span> <span class="n">debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="n">transfer</span><span class="p">)</span>

        <span class="n">bin_index</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">iter_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iter_max</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Doing Fisher step </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iter_max</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
            <span class="p">)</span>

            <span class="n">qb_new</span><span class="p">,</span> <span class="n">inv_fish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">qb_arr</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">qb_new_arr</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb_new</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dqb</span> <span class="o">=</span> <span class="n">qb_new_arr</span> <span class="o">-</span> <span class="n">qb_arr</span>
            <span class="n">fqb</span> <span class="o">=</span> <span class="n">dqb</span> <span class="o">/</span> <span class="n">qb_arr</span>
            <span class="n">max_fqb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fqb</span><span class="p">))</span>

            <span class="n">prev_fqb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_fqb</span><span class="p">)</span>

            <span class="n">fnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fqb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fnan</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="p">(</span><span class="n">nanidx</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fnan</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Ignoring </span><span class="si">{}</span><span class="s2"> bins with fqb=nan: bins=</span><span class="si">{}</span><span class="s2">, qb_new=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;qb=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">iter_idx</span><span class="p">,</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">nanidx</span><span class="p">),</span>
                        <span class="n">nanidx</span><span class="p">,</span>
                        <span class="n">qb_new_arr</span><span class="p">[</span><span class="n">nanidx</span><span class="p">],</span>
                        <span class="n">qb_arr</span><span class="p">[</span><span class="n">nanidx</span><span class="p">],</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Max fractional change in qb: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_fqb</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>

            <span class="c1"># put qb_new in original dict</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb_new</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span> <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                <span class="c1"># get beta fit and beta error</span>
                <span class="n">beta_fit</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span>
                <span class="n">db_idx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">bin_index</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">])</span>
                <span class="n">beta_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">[</span><span class="n">db_idx</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beta_fit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">beta_err</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">save_iters</span><span class="p">:</span>
                <span class="c1"># save only the quantities that change with each iteration</span>
                <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
                    <span class="n">map_tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span>
                    <span class="n">iter_index</span><span class="o">=</span><span class="n">iter_idx</span><span class="p">,</span>
                    <span class="n">bin_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">,</span>
                    <span class="n">bin_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">,</span>
                    <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
                    <span class="n">cls_obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
                    <span class="n">qb</span><span class="o">=</span><span class="n">qb</span><span class="p">,</span>
                    <span class="n">fqb</span><span class="o">=</span><span class="n">fqb</span><span class="p">,</span>
                    <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
                    <span class="n">cls_model</span><span class="o">=</span><span class="n">cls_model</span><span class="p">,</span>
                    <span class="n">cbl</span><span class="o">=</span><span class="n">cbl</span><span class="p">,</span>
                    <span class="n">cls_signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">,</span>
                    <span class="n">cls_noise</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">,</span>
                    <span class="n">Dmat_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span><span class="p">,</span>
                    <span class="n">gmat_ell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gmat_ell</span><span class="p">,</span>
                    <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">map_freqs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">,</span>
                        <span class="n">freq_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ref</span><span class="p">,</span>
                        <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="n">beta_fit</span><span class="o">=</span><span class="n">beta_fit</span><span class="p">,</span>
                            <span class="n">beta_err</span><span class="o">=</span><span class="n">beta_err</span><span class="p">,</span>
                        <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">save_name</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="ow">not</span> <span class="n">transfer</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span><span class="p">)</span>

            <span class="p">(</span><span class="n">nans</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qb_new_arr</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nans</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found NaN values in qb bins </span><span class="si">{}</span><span class="s2"> at iter </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nans</span><span class="p">,</span> <span class="n">iter_idx</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">fnan</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;All bins have fqb=NaN at iter </span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;something has gone horribly wrong.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="n">negs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">negs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Found negatives in inv_fish diagonal at locations &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="n">negs</span><span class="p">),</span>
                    <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fqb</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">converge_criteria</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="c1"># Calculate final fisher matrix without conditioning</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating final Fisher matrix.&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">inv_fish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                        <span class="n">qb</span><span class="p">,</span>
                        <span class="n">cbl</span><span class="p">,</span>
                        <span class="n">obs</span><span class="p">,</span>
                        <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                        <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                        <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># If any diagonals of inv_fisher are negative, something went wrong</span>
                <span class="n">negs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">negs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="s2">&quot;Found negatives in inv_fish diagonal at locations &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">negs</span><span class="p">),</span>
                        <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> did not converge in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;Multi-map&quot;</span> <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_tag</span><span class="p">),</span>
                    <span class="s2">&quot;transfer function&quot;</span> <span class="k">if</span> <span class="n">transfer</span> <span class="k">else</span> <span class="s2">&quot;spectrum&quot;</span><span class="p">,</span>
                    <span class="n">iter_max</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Check the slope of the last ten fqb_maxpoints.</span>
                <span class="c1"># If there&#39;s not a downward trend, adjust conditioning</span>
                <span class="c1"># criteria to help convergence.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_fqb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="ow">or</span> <span class="n">transfer</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">prev_fqb</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">:],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Not converging</span>
                    <span class="c1"># First, start from very little conditioning</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">cond_adjusted</span><span class="p">:</span>
                        <span class="n">cond_criteria</span> <span class="o">=</span> <span class="mf">5e3</span>
                        <span class="n">cond_adjusted</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Not converging. Setting cond_criteria=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iter_idx</span><span class="p">,</span> <span class="n">cond_criteria</span>
                            <span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="n">cond_criteria</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                        <span class="n">cond_criteria</span> <span class="o">/=</span> <span class="mf">2.0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Tightening condition criteria to help convergence. &quot;</span>
                            <span class="s2">&quot;cond_criteria=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iter_idx</span><span class="p">,</span> <span class="n">cond_criteria</span><span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                            <span class="s2">&quot;Iter </span><span class="si">{}</span><span class="s2">: Can&#39;t reduce cond_criteria any more.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">iter_idx</span>
                            <span class="p">),</span>
                            <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="c1"># give it ten tries to start converging</span>
                    <span class="n">prev_fqb</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># save and return</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">qb</span><span class="o">=</span><span class="n">qb</span><span class="p">,</span>
            <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
            <span class="n">fqb</span><span class="o">=</span><span class="n">fqb</span><span class="p">,</span>
            <span class="n">bin_def</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">,</span>
            <span class="n">bin_weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_weights</span><span class="p">,</span>
            <span class="n">iters</span><span class="o">=</span><span class="n">iter_idx</span><span class="p">,</span>
            <span class="n">success</span><span class="o">=</span><span class="n">success</span><span class="p">,</span>
            <span class="n">map_tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">,</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">map_freqs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">map_freqs</span><span class="p">,</span>
                <span class="n">freq_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ref</span><span class="p">,</span>
                <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                    <span class="n">beta_fit</span><span class="o">=</span><span class="n">beta_fit</span><span class="p">,</span>
                    <span class="n">beta_err</span><span class="o">=</span><span class="n">beta_err</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">cbl</span><span class="o">=</span><span class="n">cbl</span><span class="p">,</span>
                <span class="n">cls_obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_signal</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_noise</span><span class="p">,</span>
                <span class="n">cls_model</span><span class="o">=</span><span class="n">cls_model</span><span class="p">,</span>
                <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
                <span class="n">Dmat_obs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Dmat_obs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">qb_transfer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">,</span>
                <span class="n">transfer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transfer</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">template_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">transfer</span><span class="p">:</span>
            <span class="c1"># do one more fisher calc that doesn&#39;t include sample variance</span>
            <span class="c1"># set qb=very close to 0. 0 causes singular matrix problems.</span>
            <span class="c1"># don&#39;t do this for noise residual bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating final Fisher matrix without sample variance.&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">qb_zeroed</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="n">qb_new_ns</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb_zeroed</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">qb_zeroed</span><span class="p">[</span><span class="n">stag</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1e-20</span>
                    <span class="n">qb_new_ns</span><span class="p">[</span><span class="n">stag</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                <span class="n">qb_zeroed</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mf">1e-20</span>
                <span class="n">qb_new_ns</span><span class="p">[</span><span class="s2">&quot;delta_beta&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">inv_fish_ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb_zeroed</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">debias</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">invfish_nosampvar</span><span class="o">=</span><span class="n">inv_fish_ns</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># compute window functions for signal bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating signal window functions&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">wbl_qb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">obs</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">inv_fish</span><span class="o">=</span><span class="n">inv_fish</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">wbl_qb</span><span class="o">=</span><span class="n">wbl_qb</span><span class="p">)</span>

            <span class="c1"># compute bandpowers and covariances</span>
            <span class="n">cb</span><span class="p">,</span> <span class="n">dcb</span><span class="p">,</span> <span class="n">ellb</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">,</span> <span class="n">wbl_cb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_qb2cb</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish</span><span class="p">,</span> <span class="n">wbl_qb</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dcb_ns</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cov_ns</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_qb2cb</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">inv_fish_ns</span><span class="p">,</span> <span class="n">wbl_qb</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">cb</span><span class="o">=</span><span class="n">cb</span><span class="p">,</span>
                <span class="n">dcb</span><span class="o">=</span><span class="n">dcb</span><span class="p">,</span>
                <span class="n">ellb</span><span class="o">=</span><span class="n">ellb</span><span class="p">,</span>
                <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span>
                <span class="n">qb2cb</span><span class="o">=</span><span class="n">qb2cb</span><span class="p">,</span>
                <span class="n">wbl_cb</span><span class="o">=</span><span class="n">wbl_cb</span><span class="p">,</span>
                <span class="n">dcb_nosampvar</span><span class="o">=</span><span class="n">dcb_ns</span><span class="p">,</span>
                <span class="n">cov_nosampvar</span><span class="o">=</span><span class="n">cov_ns</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">like_profiles</span><span class="p">:</span>
                <span class="c1"># compute bandpower likelihoods</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating bandpower profile likelihoods&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                <span class="n">max_like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                    <span class="n">qb</span><span class="p">,</span>
                    <span class="n">cbl</span><span class="p">,</span>
                    <span class="n">obs</span><span class="p">,</span>
                    <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                    <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                    <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                    <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">dqb</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inv_fish</span><span class="p">))),</span> <span class="n">qb</span><span class="p">)</span>
                <span class="n">qb_like</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">cb_like</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">qbs</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">qb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qbs</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">like_profile_points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stag</span><span class="p">:</span>
                        <span class="n">cb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qbs</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">like_profile_points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                        <span class="p">)</span>

                    <span class="k">for</span> <span class="n">ibin</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qbs</span><span class="p">):</span>
                        <span class="n">qb1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
                        <span class="n">dq</span> <span class="o">=</span> <span class="n">dqb</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">*</span> <span class="n">like_profile_sigma</span>
                        <span class="n">q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">dq</span><span class="p">,</span> <span class="n">q</span> <span class="o">+</span> <span class="n">dq</span><span class="p">,</span> <span class="n">like_profile_points</span><span class="p">)</span>
                        <span class="n">like_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q_arr</span><span class="p">)</span>
                        <span class="n">cb_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q_arr</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q_arr</span><span class="p">):</span>
                            <span class="n">qb1</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">=</span> <span class="n">q1</span>
                            <span class="c1"># use max likelihood qb&#39;s qb2cb to convert qb-&gt;cb</span>
                            <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stag</span><span class="p">:</span>
                                <span class="n">cb_arr</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                                    <span class="s2">&quot;ij,j-&gt;i&quot;</span><span class="p">,</span> <span class="n">qb2cb</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">qb1</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                                <span class="p">)[</span><span class="n">ibin</span><span class="p">]</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                                    <span class="n">qb1</span><span class="p">,</span>
                                    <span class="n">cbl</span><span class="p">,</span>
                                    <span class="n">obs</span><span class="p">,</span>
                                    <span class="n">cls_noise</span><span class="o">=</span><span class="n">nell</span><span class="p">,</span>
                                    <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
                                    <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                                    <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                                <span class="n">like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                            <span class="n">like_arr</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">like</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> bin </span><span class="si">{}</span><span class="s2"> delta qb </span><span class="si">{}</span><span class="s2"> delta like: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">stag</span><span class="p">,</span> <span class="n">ibin</span><span class="p">,</span> <span class="n">q1</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">like</span> <span class="o">-</span> <span class="n">max_like</span>
                                <span class="p">),</span>
                                <span class="s2">&quot;debug&quot;</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="n">qb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">q_arr</span><span class="p">,</span> <span class="n">like_arr</span><span class="p">])</span>
                        <span class="k">if</span> <span class="s2">&quot;res&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stag</span><span class="p">:</span>
                            <span class="n">cb_like</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">ibin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cb_arr</span><span class="p">,</span> <span class="n">like_arr</span><span class="p">])</span>

                <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">max_like</span><span class="o">=</span><span class="n">max_like</span><span class="p">,</span> <span class="n">qb_like</span><span class="o">=</span><span class="n">qb_like</span><span class="p">,</span> <span class="n">cb_like</span><span class="o">=</span><span class="n">cb_like</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;ERROR_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;error&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="ow">not</span> <span class="n">transfer</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="XFaster.get_transfer"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_transfer">[docs]</a>    <span class="k">def</span> <span class="nf">get_transfer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fix_bb_transfer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transfer function from signal simulations created using the</span>
<span class="sd">        same spectrum as the input shape.</span>

<span class="sd">        This raises a ValueError if a negative transfer function amplitude is</span>
<span class="sd">        found.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and stops</span>
<span class="sd">            iteration.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is reached,</span>
<span class="sd">            a warning is issued.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored in an</span>
<span class="sd">            individual npz file.</span>
<span class="sd">        fix_bb_transfer : bool</span>
<span class="sd">            If True, after transfer functions have been calculated, impose the</span>
<span class="sd">            BB xfer is exactly equal to the EE transfer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transfer : OrderedDict</span>
<span class="sd">            Ell-by-ell transfer function for each map</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;transfer&#39; checkpoint, and loads or saves a</span>
<span class="sd">        data dictionary named &#39;transfer_all&#39; with the following entries:</span>

<span class="sd">            nbins:</span>
<span class="sd">                number of bins</span>
<span class="sd">            bin_def:</span>
<span class="sd">                bin definition dictionary (see ``get_bin_def``)</span>
<span class="sd">            qb_transfer:</span>
<span class="sd">                binned transfer function for each map and spectrum component</span>
<span class="sd">            transfer:</span>
<span class="sd">                ell-by-ell transfer function for each map and spectrum component</span>

<span class="sd">        Additionally the final output of ``fisher_iterate`` is stored in a</span>
<span class="sd">        dictionary called ``transfer_map&lt;idx&gt;`` for each map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">)</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">fix_bb_transfer</span><span class="o">=</span><span class="n">fix_bb_transfer</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;transfer_all&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">:</span>
            <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_wbins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">save_name</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;transfer&quot;</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># function for converting qb&#39;s to ell-by-ell transfer function</span>
        <span class="k">def</span> <span class="nf">expand_transfer</span><span class="p">(</span><span class="n">qb_transfer</span><span class="p">,</span> <span class="n">bin_def</span><span class="p">,</span> <span class="n">check_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_only</span><span class="p">:</span>
                <span class="n">transfer</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_only</span> <span class="ow">and</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb_transfer</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;cmb_&quot;</span><span class="p">)]:</span>
                    <span class="n">ftag</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;cmb_&quot;</span><span class="p">,</span> <span class="s2">&quot;fg_&quot;</span><span class="p">)</span>
                    <span class="n">qb_transfer</span><span class="p">[</span><span class="n">ftag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">m0</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">cb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bin_def</span><span class="p">[</span><span class="n">ftag</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">vint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">cb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>
                        <span class="n">qb_transfer</span><span class="p">[</span><span class="n">ftag</span><span class="p">][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vint</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="n">stag</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bin_def</span> <span class="ow">or</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb_transfer</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">stag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_only</span><span class="p">:</span>
                        <span class="n">transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> transfer bins for component </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">for</span> <span class="n">m0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">m0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>
                        <span class="n">lq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">m0</span><span class="p">])</span>
                        <span class="n">lb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">lq</span> <span class="o">!=</span> <span class="n">lb</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> transfer bins for component </span><span class="si">{}</span><span class="s2"> map </span><span class="si">{}</span><span class="s2">, expected </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">lq</span><span class="p">,</span> <span class="n">stag</span><span class="p">,</span> <span class="n">m0</span><span class="p">,</span> <span class="n">lb</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">check_only</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">spec</span> <span class="o">==</span> <span class="s2">&quot;bb&quot;</span> <span class="ow">and</span> <span class="n">fix_bb_transfer</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">transfer</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_ee&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">)][</span><span class="n">m0</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">spec</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;tb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb_transfer</span><span class="p">:</span>
                            <span class="n">staga</span><span class="p">,</span> <span class="n">stagb</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">]</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">transfer</span><span class="p">[</span><span class="n">staga</span><span class="p">][</span><span class="n">m0</span><span class="p">]</span> <span class="o">*</span> <span class="n">transfer</span><span class="p">[</span><span class="n">stagb</span><span class="p">][</span><span class="n">m0</span><span class="p">])</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">expand_qb</span><span class="p">(</span><span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">m0</span><span class="p">],</span> <span class="n">bd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_only</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">transfer</span>

        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check_only</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;transfer&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
                    <span class="n">check_only</span> <span class="o">&amp;=</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;fg_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">])</span>
                <span class="n">xfer</span> <span class="o">=</span> <span class="n">expand_transfer</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;bin_def&quot;</span><span class="p">],</span> <span class="n">check_only</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb_transfer&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">xfer</span> <span class="ow">or</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;transfer&quot;</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="s2">&quot;cmb_&quot;</span> <span class="o">+</span> <span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">im0</span><span class="p">,</span> <span class="n">m0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_transfer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">[</span><span class="n">im0</span><span class="p">]]:</span>
                <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_cmb</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Setting map </span><span class="si">{}</span><span class="s2"> transfer to unity&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Computing transfer function for map </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">im0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span>
                <span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>
            <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span> <span class="n">transfer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_iterate</span><span class="p">(</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">m0</span><span class="p">,</span>
                <span class="n">transfer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">iter_max</span><span class="o">=</span><span class="n">iter_max</span><span class="p">,</span>
                <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
                <span class="n">save_iters</span><span class="o">=</span><span class="n">save_iters</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">]</span>

            <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Error in fisher_iterate for map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>

            <span class="c1"># fix negative amplitude bins</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="p">(</span><span class="n">negbin</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Transfer function amplitude </span><span class="si">{}</span><span class="s2"> &lt; 0&quot;</span>
                        <span class="s2">&quot;for </span><span class="si">{}</span><span class="s2"> bin </span><span class="si">{}</span><span class="s2"> of map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">negbin</span><span class="p">,</span> <span class="n">m0</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># XXX cludge</span>
                    <span class="c1"># This happens in first bin</span>
                    <span class="c1"># try linear interp between zero and next value</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">negbin</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">negbin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;Setting Transfer function in negative bin to small &quot;</span>
                            <span class="s2">&quot;positive. This is probably due to choice of bins or &quot;</span>
                            <span class="s2">&quot;insufficient number of signal sims&quot;</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unable to adjust negative bins for map </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">m0</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Set EB/TB qb transfers to geometric means of components</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_eb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_ee&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">]))</span>
                <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_tb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_tt&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">qb</span><span class="p">[</span><span class="s2">&quot;cmb_bb&quot;</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">qbdat</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">m0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qbdat</span>

        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span> <span class="o">=</span> <span class="n">expand_transfer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qb_transfer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">success</span> <span class="k">else</span> <span class="s2">&quot;ERROR_&quot;</span><span class="p">,</span> <span class="n">save_name</span><span class="p">),</span>
            <span class="n">from_attrs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nbins&quot;</span><span class="p">,</span> <span class="s2">&quot;bin_def&quot;</span><span class="p">,</span> <span class="s2">&quot;qb_transfer&quot;</span><span class="p">,</span> <span class="s2">&quot;map_tags&quot;</span><span class="p">,</span> <span class="s2">&quot;transfer&quot;</span><span class="p">],</span>
            <span class="n">cls_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="p">,</span>
            <span class="n">success</span><span class="o">=</span><span class="n">success</span><span class="p">,</span>
            <span class="o">**</span><span class="n">opts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error computing transfer function: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span></div>

<div class="viewcode-block" id="XFaster.get_bandpowers"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_bandpowers">[docs]</a>    <span class="k">def</span> <span class="nf">get_bandpowers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
        <span class="n">iter_max</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">return_qb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_iters</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">delta_beta_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_criteria</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_cls</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">like_profile_sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
        <span class="n">like_profile_points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the maximum likelihood bandpowers of the data, assuming</span>
<span class="sd">        a given input spectrum shape.  Requires the transfer function to</span>
<span class="sd">        have been computed and loaded using ``get_transfer``.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If not None, then iteration is performed over the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra. In this case, the first</span>
<span class="sd">            dimension of the input cbl must be of size 1 (this is done</span>
<span class="sd">            automatically by calling ``bin_cl_template(..., map_tag=&lt;map_tag&gt;)``.</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Maximum fractional change in qb that indicates convergence and</span>
<span class="sd">            stops iteration.</span>
<span class="sd">        iter_max : int</span>
<span class="sd">            Maximum number of iterations to perform.  if this limit is</span>
<span class="sd">            reached, a warning is issued.</span>
<span class="sd">        return_qb : bool</span>
<span class="sd">            If True, only the maximum likelihood ``qb`` values are returned.</span>
<span class="sd">            Otherwise, the complete output dictionary is returned.</span>
<span class="sd">        save_iters : bool</span>
<span class="sd">            If True, the output data from each Fisher iteration are stored</span>
<span class="sd">            in an individual npz file.</span>
<span class="sd">        delta_beta_prior : float</span>
<span class="sd">            The width of the prior on the additive change from beta_ref. If you</span>
<span class="sd">            don&#39;t want the code to fit for a spectral index different</span>
<span class="sd">            from beta_ref, set this to be a very small value (O(1e-10)).</span>
<span class="sd">        cond_noise : float</span>
<span class="sd">            The level of regularizing noise to add to EE and BB diagonals.</span>
<span class="sd">        cond_criteria : float</span>
<span class="sd">            The maximum condition number allowed for Dmat1 to be acceptable</span>
<span class="sd">            for taking its inverse.</span>
<span class="sd">        null_first_cmb : bool</span>
<span class="sd">            Keep first CMB bandpowers fixed to input shape (qb=1).</span>
<span class="sd">        return_cls : bool</span>
<span class="sd">            If True, return C_ls rather than D_ls</span>
<span class="sd">        like_profiles : bool</span>
<span class="sd">            If True, compute profile likelihoods for each qb, leaving all</span>
<span class="sd">            others fixed at their maximum likelihood values.  Profiles are</span>
<span class="sd">            computed over a range +/--sigma as estimated from the diagonals</span>
<span class="sd">            of the inverse Fisher matrix.</span>
<span class="sd">        like_profile_sigma : float</span>
<span class="sd">            Range in units of 1sigma over which to compute profile likelihoods</span>
<span class="sd">        like_profile_points : int</span>
<span class="sd">            Number of points to sample along the likelihood profile</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the bandpowers filename.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Dictionary of maximum likelihood quantities, as output by</span>
<span class="sd">            ``fisher_iterate``.</span>
<span class="sd">        -- or --</span>
<span class="sd">        qb, inv_fish : array_like</span>
<span class="sd">            Maximum likelihood bandpower amplitudes and fisher covariance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is called at the &#39;bandpowers&#39; checkpoint, and loads or</span>
<span class="sd">        saves a data dictionary named &#39;bandpowers&#39; with the quantities</span>
<span class="sd">        returned by ``fisher_iterate``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;bandpowers&quot;</span>

        <span class="n">fish_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)),)</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># check all options that require rerunning fisher iterations</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># foreground fitting</span>
        <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">freq_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ref</span><span class="p">,</span>
                <span class="n">beta_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beta_ref</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;delta_beta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">:</span>
                <span class="c1"># priors on frequency spectral index</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">delta_beta_fix</span> <span class="o">=</span> <span class="mf">1.0e-8</span>
                <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_cleaned</span><span class="p">:</span>
            <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">template_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_cls</span> <span class="o">=</span> <span class="n">return_cls</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span>
            <span class="s2">&quot;bandpowers&quot;</span><span class="p">,</span>
            <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">fish_shape</span><span class="p">,</span>
            <span class="n">shape_ref</span><span class="o">=</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">,</span>
            <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
            <span class="n">value_ref</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
            <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_qb</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>

        <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_iterate</span><span class="p">(</span>
            <span class="n">cbl</span><span class="p">,</span>
            <span class="n">map_tag</span><span class="p">,</span>
            <span class="n">iter_max</span><span class="o">=</span><span class="n">iter_max</span><span class="p">,</span>
            <span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">,</span>
            <span class="n">save_iters</span><span class="o">=</span><span class="n">save_iters</span><span class="p">,</span>
            <span class="n">cond_noise</span><span class="o">=</span><span class="n">cond_noise</span><span class="p">,</span>
            <span class="n">cond_criteria</span><span class="o">=</span><span class="n">cond_criteria</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">delta_beta_prior</span><span class="o">=</span><span class="n">delta_beta_prior</span><span class="p">,</span>
            <span class="n">like_profiles</span><span class="o">=</span><span class="n">like_profiles</span><span class="p">,</span>
            <span class="n">like_profile_sigma</span><span class="o">=</span><span class="n">like_profile_sigma</span><span class="p">,</span>
            <span class="n">like_profile_points</span><span class="o">=</span><span class="n">like_profile_points</span><span class="p">,</span>
            <span class="n">file_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error computing bandpowers&quot;</span><span class="p">)</span>

        <span class="c1"># return</span>
        <span class="k">if</span> <span class="n">return_qb</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;qb&quot;</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;inv_fish&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="XFaster.get_likelihood"><a class="viewcode-back" href="../../api.html#xfaster.xfaster_class.XFaster.get_likelihood">[docs]</a>    <span class="k">def</span> <span class="nf">get_likelihood</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qb</span><span class="p">,</span>
        <span class="n">inv_fish</span><span class="p">,</span>
        <span class="n">map_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">null_first_cmb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lmin</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span>
        <span class="n">lmax</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span>
        <span class="n">mcmc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">alpha_tags</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">beam_tags</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">r_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
        <span class="n">alpha_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
        <span class="n">res_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">beam_prior</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">num_walkers</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">num_steps</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
        <span class="n">converge_criteria</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">reset_backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">file_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">r_specs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">],</span>
        <span class="n">template_specs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ee&quot;</span><span class="p">,</span> <span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;eb&quot;</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explore the likelihood, optionally with an MCMC sampler.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        qb : OrderedDict</span>
<span class="sd">            Bandpower parameters previously computed by Fisher iteration.</span>
<span class="sd">        inv_fish : array_like</span>
<span class="sd">            Inverse Fisher matrix computed with the input qb&#39;s.</span>
<span class="sd">        map_tag : string</span>
<span class="sd">            If not None, then the likelihood is sampled using the spectra</span>
<span class="sd">            corresponding to the given map, rather over all possible</span>
<span class="sd">            combinations of map-map cross-spectra.  The input qb&#39;s and inv_fish</span>
<span class="sd">            must have been computed with the same option.</span>
<span class="sd">        null_first_cmb : bool</span>
<span class="sd">            Keep first CMB bandpowers fixed to input shape (qb=1).</span>
<span class="sd">        lmin : int</span>
<span class="sd">            The minimum ell value to be included in the likelihood calculation</span>
<span class="sd">        lmax : int</span>
<span class="sd">            The maximum ell value to be included in the likelihood calculation</span>
<span class="sd">        mcmc : bool</span>
<span class="sd">            If True, sample the likelihood using an MCMC sampler.  Remaining</span>
<span class="sd">            options determine parameter space and sampler configuration.</span>
<span class="sd">        alpha_tags : list of strings</span>
<span class="sd">            List of map tags from which foreground template maps should be</span>
<span class="sd">            subtracted.  These should be the original map tags, not</span>
<span class="sd">            those generated for chunk sets.  If &quot;all&quot;, then all map tags</span>
<span class="sd">            used in the template subtraction are included, as determined by</span>
<span class="sd">            the keys in the `template_alpha` attribute.  If None, then the alpha</span>
<span class="sd">            parameters are not included in the likelihood.</span>
<span class="sd">        beam_tags : list of strings</span>
<span class="sd">            List of map tags from which beam error envelopes should be</span>
<span class="sd">            marginalized over. These should be the original map tags, not</span>
<span class="sd">            those generated for chunk sets.  If &quot;all&quot;, then all available map</span>
<span class="sd">            tags in the dataset are included.  If None, then the beam error</span>
<span class="sd">            parameters are not included in the likelihood.</span>
<span class="sd">        r_prior : 2-list or None</span>
<span class="sd">            Prior upper and lower bound on tensor to scalar ratio.  If None, the</span>
<span class="sd">            fiducial shape spectrum is assumed, and the r parameter space is not</span>
<span class="sd">            varied.</span>
<span class="sd">        alpha_prior : 2-list or None</span>
<span class="sd">            Prior upper and lower bound on template coefficients.  If None, the</span>
<span class="sd">            alpha parameter space is not varied.</span>
<span class="sd">        res_prior : 2-list or none</span>
<span class="sd">            Prior upper and lower bound on residual qbs.  If None, the</span>
<span class="sd">            res parameter space is not varied.</span>
<span class="sd">        beam_prior : 2-list or none</span>
<span class="sd">            Prior mean and width of gaussian width on beam error (when</span>
<span class="sd">            multiplied by beam error envelope).  If None, the</span>
<span class="sd">            beam parameter space is not varied.</span>
<span class="sd">        num_walkers : int</span>
<span class="sd">            Number of unique walkers with which to sample the parameter space.</span>
<span class="sd">        num_steps : int</span>
<span class="sd">            Maximum number of steps each walker can take in sampling the</span>
<span class="sd">            parameter space.</span>
<span class="sd">        converge_criteria : float</span>
<span class="sd">            Convergence criteria for likelihood MCMC chains</span>
<span class="sd">        reset_backend : bool</span>
<span class="sd">            If True, clear the backend buffer before sampling.  If False,</span>
<span class="sd">            samples are appended to the existing buffer.  If not supplied,</span>
<span class="sd">            set to True if the checkpoint has been forced to be rerun.</span>
<span class="sd">        file_tag : string</span>
<span class="sd">            If supplied, appended to the likelihood filename.</span>
<span class="sd">        r_specs : list</span>
<span class="sd">            Which spectra to use in the r likelihood.</span>
<span class="sd">        template_specs : list</span>
<span class="sd">            Which spectra to use for alpha in the likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if OMP threads &gt; 1. It actually slows the code way down to have</span>
        <span class="c1"># more threads. Break instead.</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;OMP_NUM_THREADS&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="p">],</span> <span class="s2">&quot;OMP threads must be set to 1 for likelihood&quot;</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">r_prior</span><span class="p">,</span>
            <span class="n">alpha_prior</span><span class="p">,</span>
            <span class="n">res_prior</span><span class="p">,</span>
            <span class="n">beam_prior</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="n">r_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r_specs</span><span class="p">]</span>
        <span class="n">template_specs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template_specs</span><span class="p">]</span>

        <span class="n">save_name</span> <span class="o">=</span> <span class="s2">&quot;like_mcmc&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span><span class="p">:</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">res_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">beam_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># no template cleaning if there aren&#39;t any templates specified</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_cleaned&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># null out unused priors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;template_alpha&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># count alpha parameters to fit</span>
        <span class="k">if</span> <span class="n">alpha_tags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">alpha_tags</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">alpha_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">alpha_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">alpha_tags</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">):</span>
            <span class="n">alpha_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">num_alpha</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_alpha</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">)</span>

        <span class="c1"># count beam parameters to fit</span>
        <span class="k">if</span> <span class="n">beam_tags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">beam_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">beam_tags</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">beam_tags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">)</span>
        <span class="n">beam_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">beam_tags</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_tags_orig</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">):</span>
            <span class="n">beam_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">num_beam</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_beam</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">]):</span>
            <span class="n">res_prior</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># bookkeeping: ordered priors</span>
        <span class="n">priors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;r_prior&quot;</span><span class="p">:</span> <span class="n">r_prior</span><span class="p">,</span>
            <span class="s2">&quot;alpha_prior&quot;</span><span class="p">:</span> <span class="n">alpha_prior</span><span class="p">,</span>
            <span class="s2">&quot;res_prior&quot;</span><span class="p">:</span> <span class="n">res_prior</span><span class="p">,</span>
            <span class="s2">&quot;beam_prior&quot;</span><span class="p">:</span> <span class="n">beam_prior</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># priors on quantities that affect Dmat_obs or gmat (precalculated)</span>
        <span class="n">obs_priors</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha_prior</span><span class="p">]</span>

        <span class="c1"># check parameter space</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Empty parameter space&quot;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">r_prior</span><span class="o">=</span><span class="n">r_prior</span><span class="p">,</span>
            <span class="n">alpha_prior</span><span class="o">=</span><span class="n">alpha_prior</span><span class="p">,</span>
            <span class="n">res_prior</span><span class="o">=</span><span class="n">res_prior</span><span class="p">,</span>
            <span class="n">beam_prior</span><span class="o">=</span><span class="n">beam_prior</span><span class="p">,</span>
            <span class="n">alpha_tags</span><span class="o">=</span><span class="n">alpha_tags</span><span class="p">,</span>
            <span class="n">num_walkers</span><span class="o">=</span><span class="n">num_walkers</span><span class="p">,</span>
            <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
            <span class="n">apply_gcorr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_gcorr</span><span class="p">,</span>
            <span class="n">weighted_bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_bins</span><span class="p">,</span>
            <span class="n">lmin</span><span class="o">=</span><span class="n">lmin</span><span class="p">,</span>
            <span class="n">lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mcmc</span> <span class="ow">and</span> <span class="n">reset_backend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span>
                <span class="s2">&quot;likelihood&quot;</span><span class="p">,</span>
                <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">to_attrs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span>
                <span class="n">value_ref</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;converged&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">converge_criteria</span> <span class="o">&gt;=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;converge_criteria&quot;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">ret</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pval</span> <span class="o">!=</span> <span class="n">ret</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># clear chain cache if rerunning, otherwise append to chain by default</span>
            <span class="n">reset_backend</span> <span class="o">=</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converge_criteria</span><span class="o">=</span><span class="n">converge_criteria</span><span class="p">)</span>

        <span class="c1"># save state</span>
        <span class="k">if</span> <span class="n">mcmc</span> <span class="ow">and</span> <span class="n">reset_backend</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
            <span class="p">)</span>

        <span class="c1"># clear pre-computed quantities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_precalc</span><span class="p">()</span>
        <span class="n">use_precalc</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obs_priors</span><span class="p">])</span>

        <span class="n">cls_input</span><span class="p">,</span> <span class="n">cls_noise</span><span class="p">,</span> <span class="n">cls_debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">()</span>

        <span class="c1"># extract residual bins, ignoring bins outside of lmin/lmax</span>
        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_def_orig</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">)</span>
            <span class="n">nbins_res_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span>
            <span class="n">qb_res</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">num_res</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">qb</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;res_&quot;</span><span class="p">):</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">bd</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># use all qb res in range lmin, lmax</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bd</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="n">good</span><span class="p">]</span>
                    <span class="n">num_res</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">qb_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">num_res</span>

        <span class="c1"># set CMB model bandpowers to unity, since we are computing</span>
        <span class="c1"># the likelihood of this model given the data</span>
        <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing model spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Beam variation not implemented for case of no r fit&quot;</span><span class="p">)</span>
            <span class="n">cbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">cbl</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qb</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">:</span>
                <span class="n">stags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">stag</span> <span class="ow">in</span> <span class="n">stags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qb</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">qb</span><span class="p">[</span><span class="n">stag</span><span class="p">])</span>
            <span class="n">qb_cmb</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;cmb_&quot;</span><span class="p">)]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing r model spectrum&quot;</span><span class="p">,</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="n">cls_shape_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">(</span>
                <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;scalar&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;fg&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal_components</span><span class="p">:</span>
                <span class="n">cls_shape_scalar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">cls</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_shape</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;fg_&quot;</span><span class="p">)}</span>
                <span class="p">)</span>

            <span class="n">cls_shape_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_signal_shape</span><span class="p">(</span>
                <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s2">&quot;tensor&quot;</span>
            <span class="p">)</span>

            <span class="c1"># load tensor and scalar terms separately</span>
            <span class="n">cbl_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">cls_shape_scalar</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model_scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span> <span class="n">cbl_scalar</span><span class="p">,</span> <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span>
            <span class="p">)</span>
            <span class="n">cbl_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span><span class="n">cls_shape_tensor</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">)</span>
            <span class="n">cls_model_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb_cmb</span><span class="p">,</span> <span class="n">cbl_tensor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># load beam error term for tensor and scalar</span>
                <span class="n">cbl_scalar_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                    <span class="n">cls_shape_scalar</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">,</span> <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">cls_mod_scal_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">cbl_scalar_beam</span><span class="p">)</span>
                <span class="n">cbl_tensor_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_cl_template</span><span class="p">(</span>
                    <span class="n">cls_shape_tensor</span><span class="p">,</span> <span class="n">map_tag</span><span class="p">,</span> <span class="n">beam_error</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">cls_mod_tens_beam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">qb_cmb</span><span class="p">,</span> <span class="n">cbl_tensor_beam</span><span class="p">)</span>

            <span class="n">cbl</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cbl_scalar</span><span class="p">)</span>
            <span class="n">cls_model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model_scalar</span><span class="p">)</span>

        <span class="c1"># XXX TODO</span>
        <span class="c1"># how to marginalize over the garbage bin?</span>

        <span class="k">def</span> <span class="nf">parse_params</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Parse array of parameters into a dict</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;alpha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_alpha</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_alpha</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_res</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_res</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;beam&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="n">num_beam</span><span class="p">]</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">num_beam</span><span class="p">:]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many parameters to parse&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">params</span>

        <span class="k">def</span> <span class="nf">log_prior</span><span class="p">(</span>
            <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">beam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log prior function constructed from input options</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;r_prior&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span>
                <span class="s2">&quot;alpha_prior&quot;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span>
                <span class="s2">&quot;res_prior&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pval</span> <span class="o">&lt;</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pval</span> <span class="o">&gt;</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="n">values_gauss</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;beam_prior&quot;</span><span class="p">:</span> <span class="n">beam</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="c1"># for beam, use gaussian prior</span>
            <span class="n">log_prob</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">pval</span> <span class="ow">in</span> <span class="n">values_gauss</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">prior</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
                    <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">pval</span> <span class="o">-</span> <span class="n">prior</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">prior</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">log_prob</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span> <span class="o">-</span> <span class="n">chi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">log_prob</span>

        <span class="k">def</span> <span class="nf">log_like</span><span class="p">(</span>
            <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">beam</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log likelihood function constructed from input options</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cls_model0</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model</span><span class="p">)</span>

            <span class="c1"># compute new template subtracted data spectra</span>
            <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clsi</span> <span class="o">=</span> <span class="n">cls_input</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_masked_data</span><span class="p">(</span>
                    <span class="n">template_alpha</span><span class="o">=</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">alpha_tags</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)),</span>
                    <span class="n">template_specs</span><span class="o">=</span><span class="n">template_specs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">clsi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_spectra</span><span class="p">(</span><span class="n">do_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">beam</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">,</span> <span class="n">beam</span><span class="p">))</span>
                <span class="n">beam_coeffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_pairs_orig</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">beam</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">b0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span>
                    <span class="k">if</span> <span class="n">b1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>
                        <span class="k">if</span> <span class="n">b0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;b3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">b1</span>
                    <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

            <span class="c1"># compute new signal shape by scaling tensor component by r</span>
            <span class="c1"># XXX handle beam fg terms here too</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_specs</span> <span class="ow">or</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">cls_model_scalar</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                            <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cls_model_tensor</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">beam</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">beam_term</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">beam_term</span> <span class="o">+=</span> <span class="n">bc</span> <span class="o">*</span> <span class="p">(</span>
                                <span class="n">cls_mod_scal_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                                <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cls_mod_tens_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">beam_term</span>

            <span class="k">elif</span> <span class="n">beam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_model0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">comp</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">stag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">spec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_specs</span> <span class="ow">or</span> <span class="n">comp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cmb&quot;</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">ctag</span> <span class="o">=</span> <span class="s2">&quot;cmb_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">beam_term</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">beam_coeffs</span><span class="p">[</span><span class="n">xname</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">beam_term</span> <span class="o">+=</span> <span class="n">bc</span> <span class="o">*</span> <span class="n">cls_mod_scal_beam</span><span class="p">[</span><span class="n">ctag</span><span class="p">][</span><span class="n">xname</span><span class="p">][</span><span class="n">bn</span><span class="p">]</span>
                        <span class="n">dd</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cls_model_scalar</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+</span> <span class="n">beam_term</span>

            <span class="c1"># compute noise model terms</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clsm</span> <span class="o">=</span> <span class="n">cls_model0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">arr_to_dict</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">qb_res</span><span class="p">)</span>
                <span class="n">clsm</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cls_model0</span><span class="p">)</span>
                <span class="n">cls_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_spectra</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">cbl</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">stag</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cls_res</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">stag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clsm</span><span class="p">:</span>
                        <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">xname</span><span class="p">,</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">xname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">]:</span>
                            <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">=</span> <span class="n">dd</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">clsm</span><span class="p">[</span><span class="n">stag</span><span class="p">][</span><span class="n">xname</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dd</span>

            <span class="c1"># compute likelihood</span>
            <span class="n">like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_calc</span><span class="p">(</span>
                <span class="n">qb</span><span class="p">,</span>
                <span class="n">cbl</span><span class="p">,</span>
                <span class="n">clsi</span><span class="p">,</span>
                <span class="n">cls_noise</span><span class="o">=</span><span class="n">cls_noise</span><span class="p">,</span>
                <span class="n">cls_debias</span><span class="o">=</span><span class="n">cls_debias</span><span class="p">,</span>
                <span class="n">cls_model</span><span class="o">=</span><span class="n">clsm</span><span class="p">,</span>
                <span class="n">null_first_cmb</span><span class="o">=</span><span class="n">null_first_cmb</span><span class="p">,</span>
                <span class="n">likelihood</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">use_precalc</span><span class="o">=</span><span class="n">use_precalc</span><span class="p">,</span>
                <span class="n">like_lmin</span><span class="o">=</span><span class="n">lmin</span><span class="p">,</span>
                <span class="n">like_lmax</span><span class="o">=</span><span class="n">lmax</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">like</span>

        <span class="k">def</span> <span class="nf">log_prob</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Log posterior probability from prior and likelihood</span>

<span class="sd">            Returns log_prior with each step</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">parse_params</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">prior</span> <span class="o">=</span> <span class="n">log_prior</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">prior</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">like</span> <span class="o">=</span> <span class="n">log_like</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">like</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">prior</span>
            <span class="k">return</span> <span class="n">prior</span> <span class="o">+</span> <span class="n">like</span><span class="p">,</span> <span class="n">prior</span>

        <span class="c1"># initial values</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span> <span class="k">else</span> <span class="kc">False</span>  <span class="c1"># only vary r</span>
        <span class="k">if</span> <span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">alpha_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">template_alpha</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">alpha_tags</span><span class="p">]</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alphas</span><span class="p">]</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">dict_to_arr</span><span class="p">(</span><span class="n">qb_res</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">beam_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># add a beam term for each frequency</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_tags</span><span class="p">)</span>
            <span class="n">brute_force</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">num_walkers</span><span class="p">:</span>
            <span class="n">num_walkers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ndim</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">))</span> <span class="o">*</span> <span class="n">num_walkers</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> parameters, increasing number of MCMC walkers to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">ndim</span><span class="p">,</span> <span class="n">num_walkers</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">brute_force</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Computing brute-force r profile likelihood&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
            <span class="n">likefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span>
                <span class="n">save_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
            <span class="n">likes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rs</span><span class="p">):</span>
                <span class="n">like</span> <span class="o">=</span> <span class="n">log_like</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">20</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;r = </span><span class="si">{:.3f}</span><span class="s2">, loglike = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">like</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
                <span class="n">likes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">like</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> r likelihood</span><span class="se">\n</span><span class="s2">Columns: r, loglike&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s2">&quot;Multi-map&quot;</span> <span class="k">if</span> <span class="n">map_tag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Map </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">map_tag</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">likefile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">rs</span><span class="p">,</span> <span class="n">likes</span><span class="p">)),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mcmc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">rs</span><span class="p">,</span> <span class="n">likes</span><span class="p">]</span>

        <span class="c1"># run chains!</span>
        <span class="kn">import</span> <span class="nn">emcee</span>

        <span class="c1"># setup sampler output file</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filename</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">backend_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">HDFBackend</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">backend_exists</span> <span class="ow">and</span> <span class="n">backend</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Expected backend of shape (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), found </span><span class="si">{}</span><span class="s2">. Resetting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">backend</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">reset_backend</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">reset_backend</span><span class="p">:</span>
            <span class="n">backend</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>

        <span class="c1"># initialize sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Initializing sampler&quot;</span><span class="p">,</span> <span class="s2">&quot;info&quot;</span><span class="p">)</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">num_walkers</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">log_prob</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reset_backend</span> <span class="ow">and</span> <span class="n">backend_exists</span><span class="p">:</span>
            <span class="c1"># grab the last sample if appending to an existing run</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># track autocorrelation time</span>
        <span class="n">old_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;Starting </span><span class="si">{}</span><span class="s2"> iterations with </span><span class="si">{}</span><span class="s2"> parameters&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">ndim</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;MCMC iteration </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">),</span> <span class="s2">&quot;debug&quot;</span><span class="p">)</span>
            <span class="c1"># check convergence every 100 steps</span>
            <span class="k">if</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># compute autocorrelation time</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_autocorr_time</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># check convergence</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">tau</span> <span class="o">/</span> <span class="n">converge_criteria</span> <span class="o">&lt;</span> <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>
            <span class="n">converged</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">old_tau</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">&lt;</span> <span class="n">converge_criteria</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;MCMC iteration </span><span class="si">{}</span><span class="s2"> autocorr time: mean </span><span class="si">{:.1f}</span><span class="s2"> min </span><span class="si">{:.1f}</span><span class="s2"> max </span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;info&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">converged</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">old_tau</span> <span class="o">=</span> <span class="n">tau</span>

        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">converged</span><span class="o">=</span><span class="n">converged</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># converged posterior distribution</span>
        <span class="k">if</span> <span class="n">converged</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;MCMC converged in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">iteration</span><span class="p">),</span> <span class="s2">&quot;info&quot;</span>
            <span class="p">)</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_autocorr_time</span><span class="p">()</span>
            <span class="n">burnin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
            <span class="n">thin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tau</span><span class="p">))</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_chain</span><span class="p">(</span><span class="n">discard</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">burnin</span><span class="o">=</span><span class="n">burnin</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MCMC not converged in </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_steps</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">res_prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_def</span> <span class="o">=</span> <span class="n">bin_def_orig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nbins_res</span> <span class="o">=</span> <span class="n">nbins_res_orig</span>

        <span class="c1"># save and return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span>
            <span class="n">save_name</span><span class="p">,</span> <span class="n">map_tag</span><span class="o">=</span><span class="n">map_tag</span><span class="p">,</span> <span class="n">extra_tag</span><span class="o">=</span><span class="n">file_tag</span><span class="p">,</span> <span class="n">bp_opts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">out</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, A. Gambrel, A. Rahlin, C. Contaldi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>